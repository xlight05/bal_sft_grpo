[
  {
    "id": "request-0",
    "prompt": "Check if in given array of numbers, are any two numbers closer to each other than given threshold.\n\n// has_close_elements([1.0, 2.0, 3.0], 0.5) → false\n// has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) → true\n\nfunction has_close_elements(numbers: float[], threshold: float) returns boolean {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testHasCloseElements1() {\n    boolean result = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3);\n    test:assertTrue(result, msg = \"Expected true for close elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements2() {\n    boolean result = has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05);\n    test:assertFalse(result, msg = \"Expected false for distant elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements3() {\n    boolean result = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95);\n    test:assertTrue(result, msg = \"Expected true for close elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements4() {\n    boolean result = has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8);\n    test:assertFalse(result, msg = \"Expected false for distant elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements5() {\n    boolean result = has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1);\n    test:assertTrue(result, msg = \"Expected true for close elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements6() {\n    boolean result = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0);\n    test:assertTrue(result, msg = \"Expected true for close elements\");\n}\n\n@test:Config { }\nfunction testHasCloseElements7() {\n    boolean result = has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5);\n    test:assertFalse(result, msg = \"Expected false for distant elements\");\n}"
  },
  {
    "id": "request-1",
    "prompt": "Write a function that takes a string containing multiple groups of nested parentheses and separates those groups into separate strings, returning an array of those strings.\n\nThe separate groups are balanced (each open brace is properly closed) and not nested within each other. You should ignore any spaces in the input string.\n\n```ballerina\nfunction separate_paren_groups(paren_string string) returns string[]\n```\n\nExample:\n```ballerina\nseparate_paren_groups(\"( ) (( )) (( )( ))\") // returns [\"()\", \"(())\", \"(()())\"]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSeparateParenGroups1() {\n    string[] result = separate_paren_groups(\"(()()) ((())) () ((())()())\");\n    string[] expected = [\"(()())\", \"((()))\", \"()\", \"((())()())\"];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSeparateParenGroups2() {\n    string[] result = separate_paren_groups(\"() (()) ((())) (((())))\");\n    string[] expected = [\"()\", \"(())\", \"((()))\", \"(((())))\"]; \n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSeparateParenGroups3() {\n    string[] result = separate_paren_groups(\"(()(())((())))\");\n    string[] expected = [\"(()(())((())))\"]; \n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSeparateParenGroups4() {\n    string[] result = separate_paren_groups(\"( ) (( )) (( )( ))\");\n    string[] expected = [\"()\", \"(())\", \"(()())\"]; \n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}"
  },
  {
    "id": "request-2",
    "prompt": "Given a positive floating point number, it can be decomposed into an integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1). Return the decimal part of the number.\n\n```ballerina\nfunction truncate_number(number float) returns float {\n    // Your implementation here\n}\n```\n\nExpected function calls:\n```ballerina\ntruncate_number(3.5) // returns 0.5\ntruncate_number(1.25) // returns 0.25  \ntruncate_number(123.0) // returns 0.0\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTruncateNumber1() {\n    float result = truncate_number(3.5);\n    test:assertEquals(result, 0.5, msg = \"Expected 0.5 for input 3.5\");\n}\n\n@test:Config { }\nfunction testTruncateNumber2() {\n    float result = truncate_number(1.25);\n    test:assertEquals(result, 0.25, msg = \"Expected 0.25 for input 1.25\");\n}\n\n@test:Config { }\nfunction testTruncateNumber3() {\n    float result = truncate_number(123.0);\n    test:assertEquals(result, 0.0, msg = \"Expected 0.0 for input 123.0\");\n}"
  },
  {
    "id": "request-3",
    "prompt": "You're given an array of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account falls below zero, and at that point function should return true. Otherwise it should return false.\n\n```ballerina\nfunction below_zero(int[] operations) returns boolean {\n    // Your implementation here\n}\n```\n\nExample calls:\n// below_zero([1, 2, 3]) returns false\n// below_zero([1, 2, -4, 5]) returns true",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testBelowZeroEmpty() {\n    boolean result = below_zero([]);\n    test:assertFalse(result, msg = \"Empty array should return false\");\n}\n\n@test:Config { }\nfunction testBelowZeroBalanced() {\n    boolean result = below_zero([1, 2, -3, 1, 2, -3]);\n    test:assertFalse(result, msg = \"Balanced operations should return false\");\n}\n\n@test:Config { }\nfunction testBelowZeroGoesNegative() {\n    boolean result = below_zero([1, 2, -4, 5, 6]);\n    test:assertTrue(result, msg = \"Operations going negative should return true\");\n}\n\n@test:Config { }\nfunction testBelowZeroAlternating() {\n    boolean result = below_zero([1, -1, 2, -2, 5, -5, 4, -4]);\n    test:assertFalse(result, msg = \"Alternating operations staying non-negative should return false\");\n}\n\n@test:Config { }\nfunction testBelowZeroAlternatingNegative() {\n    boolean result = below_zero([1, -1, 2, -2, 5, -5, 4, -5]);\n    test:assertTrue(result, msg = \"Alternating operations going negative should return true\");\n}\n\n@test:Config { }\nfunction testBelowZeroEarlyNegative() {\n    boolean result = below_zero([1, -2, 2, -2, 5, -5, 4, -4]);\n    test:assertTrue(result, msg = \"Early negative balance should return true\");\n}"
  },
  {
    "id": "request-4",
    "prompt": "For a given array of input numbers, calculate Mean Absolute Deviation around the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n\nFor example:\nmean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) should return 1.0\n\nWrite a function with this signature:\nfunction mean_absolute_deviation(numbers float[]) returns float",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMeanAbsoluteDeviation1() {\n    float result = mean_absolute_deviation([1.0, 2.0]);\n    test:assertEquals(result, 0.5, msg = \"MAD calculation failed for [1.0, 2.0]\");\n}\n\n@test:Config { }\nfunction testMeanAbsoluteDeviation2() {\n    float result = mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]);\n    test:assertEquals(result, 1.0, msg = \"MAD calculation failed for [1.0, 2.0, 3.0, 4.0]\");\n}\n\n@test:Config { }\nfunction testMeanAbsoluteDeviation3() {\n    float result = mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]);\n    test:assertEquals(result, 1.2, msg = \"MAD calculation failed for [1.0, 2.0, 3.0, 4.0, 5.0]\");\n}"
  },
  {
    "id": "request-5",
    "prompt": "Insert a number 'delimiter' between every two consecutive elements of input array 'numbers'. For an empty array, return an empty array. For arrays with elements, place the delimiter between each pair of consecutive elements.\n\nExamples:\n// intersperse([], 4) returns []\n// intersperse([1, 2, 3], 4) returns [1, 4, 2, 4, 3]\n\nfunction intersperse(numbers: int[], delimiter: int) returns int[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testIntersperseEmpty() {\n    int[] result = intersperse([], 7);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for empty array\");\n}\n\n@test:Config {}\nfunction testIntersperseMultipleElements() {\n    int[] result = intersperse([5, 6, 3, 2], 8);\n    int[] expected = [5, 8, 6, 8, 3, 8, 2];\n    test:assertEquals(result, expected, msg = \"Failed for multiple elements\");\n}\n\n@test:Config {}\nfunction testIntersperseRepeatedElements() {\n    int[] result = intersperse([2, 2, 2], 2);\n    int[] expected = [2, 2, 2, 2, 2];\n    test:assertEquals(result, expected, msg = \"Failed for repeated elements\");\n}"
  },
  {
    "id": "request-6",
    "prompt": "// Write a function that takes a string containing multiple groups of nested parentheses separated by spaces.\n// For each group, determine the deepest level of nesting of parentheses.\n// For example: \"(()())\" has a maximum nesting depth of 2, while \"((()))\" has a depth of 3.\n// \n// Example usage:\n// parse_nested_parens(\"(()()) ((())) () ((())()())\") should return [2, 3, 1, 3]\n// parse_nested_parens(\"() (()) ((())) (((())))\")  should return [1, 2, 3, 4]\n// parse_nested_parens(\"(()(())((())))\")  should return [4]\n\nfunction parse_nested_parens(paren_string: string): int[] {",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testParseNestedParens1() {\n    int[] result = parse_nested_parens(\"(()()) ((())) () ((())()())\");\n    int[] expected = [2, 3, 1, 3];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testParseNestedParens2() {\n    int[] result = parse_nested_parens(\"() (()) ((())) (((()))\");\n    int[] expected = [1, 2, 3, 4];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testParseNestedParens3() {\n    int[] result = parse_nested_parens(\"(()(())((()))\");\n    int[] expected = [4];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}"
  },
  {
    "id": "request-7",
    "prompt": "Filter an input array of strings only for ones that contain given substring.\n\n// filter_by_substring([], \"a\")\n// []\n// filter_by_substring([\"abc\", \"bacd\", \"cde\", \"array\"], \"a\")\n// [\"abc\", \"bacd\", \"array\"]\n\nfunction filter_by_substring(strings: string[], substring: string) returns string[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFilterBySubstring() {\n    test:assertEquals(filter_by_substring([], \"john\"), [], msg = \"Empty array test failed\");\n    test:assertEquals(filter_by_substring([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\"), [\"xxx\", \"xxxAAA\", \"xxx\"], msg = \"Filter by 'xxx' test failed\");\n    test:assertEquals(filter_by_substring([\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xx\"), [\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"], msg = \"Filter by 'xx' test failed\");\n    test:assertEquals(filter_by_substring([\"grunt\", \"trumpet\", \"prune\", \"gruesome\"], \"run\"), [\"grunt\", \"prune\"], msg = \"Filter by 'run' test failed\");\n}"
  },
  {
    "id": "request-8",
    "prompt": "For a given array of integers, return an array consisting of a sum and a product of all the integers in an array. Empty sum should be equal to 0 and empty product should be equal to 1.\n\nExamples:\n// sum_product([])\n// [0, 1]\n// sum_product([1, 2, 3, 4])\n// [10, 24]\n\nfunction sum_product(numbers: int[]) returns [int, int] {\n    \n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyArray() {\n    [int, int] result = sum_product([]);\n    test:assertEquals(result, [0, 1], msg = \"Empty array should return [0, 1]\");\n}\n\n@test:Config { }\nfunction testOnesArray() {\n    [int, int] result = sum_product([1, 1, 1]);\n    test:assertEquals(result, [3, 1], msg = \"Array of ones should return [3, 1]\");\n}\n\n@test:Config { }\nfunction testWithZero() {\n    [int, int] result = sum_product([100, 0]);\n    test:assertEquals(result, [100, 0], msg = \"Array with zero should return [100, 0]\");\n}\n\n@test:Config { }\nfunction testNormalArray() {\n    [int, int] result = sum_product([3, 5, 7]);\n    test:assertEquals(result, [15, 105], msg = \"Array [3, 5, 7] should return [15, 105]\");\n}\n\n@test:Config { }\nfunction testSingleElement() {\n    [int, int] result = sum_product([10]);\n    test:assertEquals(result, [10, 10], msg = \"Single element array should return [10, 10]\");\n}"
  },
  {
    "id": "request-9",
    "prompt": "From a given array of integers, generate an array of rolling maximum element found until given moment in the sequence.\n\nfunction rolling_max(numbers: int[]): int[]\n\n// rolling_max([1, 2, 3, 2, 3, 4, 2]) should return [1, 2, 3, 3, 3, 4, 4]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testRollingMaxEmpty() {\n    int[] result = rolling_max([]);\n    test:assertEquals(result, [], msg = \"Rolling max of empty array should be empty\");\n}\n\n@test:Config { }\nfunction testRollingMaxIncreasing() {\n    int[] result = rolling_max([1, 2, 3, 4]);\n    test:assertEquals(result, [1, 2, 3, 4], msg = \"Rolling max of increasing sequence failed\");\n}\n\n@test:Config { }\nfunction testRollingMaxDecreasing() {\n    int[] result = rolling_max([4, 3, 2, 1]);\n    test:assertEquals(result, [4, 4, 4, 4], msg = \"Rolling max of decreasing sequence failed\");\n}\n\n@test:Config { }\nfunction testRollingMaxMixed() {\n    int[] result = rolling_max([3, 2, 3, 100, 3]);\n    test:assertEquals(result, [3, 3, 3, 100, 100], msg = \"Rolling max of mixed sequence failed\");\n}"
  },
  {
    "id": "request-10",
    "prompt": "Find the shortest palindrome that begins with a supplied string. The algorithm works by finding the longest postfix of the supplied string that is a palindrome, then appending to the end of the string the reverse of the string prefix that comes before the palindromic suffix.\n\n```ballerina\nfunction make_palindrome(string str) returns string {\n    // Your implementation here\n}\n```\n\nExample calls:\n```ballerina\nmake_palindrome(\"\") // \"\"\nmake_palindrome(\"cat\") // \"catac\"\nmake_palindrome(\"cata\") // \"catac\"\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMakePalindromeEmpty() {\n    test:assertEquals(make_palindrome(\"\"), \"\", msg = \"Empty string test failed\");\n}\n\n@test:Config { }\nfunction testMakePalindromeSingleChar() {\n    test:assertEquals(make_palindrome(\"x\"), \"x\", msg = \"Single character test failed\");\n}\n\n@test:Config { }\nfunction testMakePalindromeXyz() {\n    test:assertEquals(make_palindrome(\"xyz\"), \"xyzyx\", msg = \"XYZ test failed\");\n}\n\n@test:Config { }\nfunction testMakePalindromeXyx() {\n    test:assertEquals(make_palindrome(\"xyx\"), \"xyx\", msg = \"XYX test failed\");\n}\n\n@test:Config { }\nfunction testMakePalindromeJerry() {\n    test:assertEquals(make_palindrome(\"jerry\"), \"jerryrrej\", msg = \"Jerry test failed\");\n}"
  },
  {
    "id": "request-11",
    "prompt": "// Given two strings a and b consisting only of 1s and 0s, perform binary XOR on these inputs and return the result as a string.\n// string_xor(\"010\", \"110\") should return \"100\"\nfunction string_xor(a: string, b: string): string {",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStringXor1() {\n    string result = string_xor(\"111000\", \"101010\");\n    test:assertEquals(result, \"010010\", msg = \"XOR operation failed for test case 1\");\n}\n\n@test:Config { }\nfunction testStringXor2() {\n    string result = string_xor(\"1\", \"1\");\n    test:assertEquals(result, \"0\", msg = \"XOR operation failed for test case 2\");\n}\n\n@test:Config { }\nfunction testStringXor3() {\n    string result = string_xor(\"0101\", \"0000\");\n    test:assertEquals(result, \"0101\", msg = \"XOR operation failed for test case 3\");\n}"
  },
  {
    "id": "request-12",
    "prompt": "Given an array of strings, return the longest one. If there are multiple strings of the same length, return the first one that appears. If the input array is empty, return `()` (nil).\n\n```ballerina\nfunction longest(strings string[]) returns string? {\n    // Your implementation here\n}\n```\n\nExamples:\n- `longest([])` should return `()`\n- `longest([\"a\", \"b\", \"c\"])` should return `\"a\"`\n- `longest([\"a\", \"bb\", \"ccc\"])` should return `\"ccc\"`",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testLongestEmpty() {\n    string[] empty = [];\n    string? result = longest(empty);\n    test:assertEquals(result, (), msg = \"Empty array should return nil\");\n}\n\n@test:Config { }\nfunction testLongestSameLength() {\n    string[] strings = [\"x\", \"y\", \"z\"];\n    string? result = longest(strings);\n    test:assertEquals(result, \"x\", msg = \"Should return first string when all have same length\");\n}\n\n@test:Config { }\nfunction testLongestMultipleLengths() {\n    string[] strings = [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"];\n    string? result = longest(strings);\n    test:assertEquals(result, \"zzzz\", msg = \"Should return first occurrence of longest string\");\n}"
  },
  {
    "id": "request-13",
    "prompt": "Write a function that returns the greatest common divisor of two integers a and b.\n\n```ballerina\nfunction greatest_common_divisor(int a, int b) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n// greatest_common_divisor(3, 5) should return 1\n// greatest_common_divisor(25, 15) should return 5",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGcd1() {\n    int result = greatest_common_divisor(3, 7);\n    test:assertEquals(result, 1, msg = \"GCD of 3 and 7 should be 1\");\n}\n\n@test:Config { }\nfunction testGcd2() {\n    int result = greatest_common_divisor(10, 15);\n    test:assertEquals(result, 5, msg = \"GCD of 10 and 15 should be 5\");\n}\n\n@test:Config { }\nfunction testGcd3() {\n    int result = greatest_common_divisor(49, 14);\n    test:assertEquals(result, 7, msg = \"GCD of 49 and 14 should be 7\");\n}\n\n@test:Config { }\nfunction testGcd4() {\n    int result = greatest_common_divisor(144, 60);\n    test:assertEquals(result, 12, msg = \"GCD of 144 and 60 should be 12\");\n}"
  },
  {
    "id": "request-14",
    "prompt": "Return an array of all prefixes from shortest to longest of the input string.\n\n```ballerina\nfunction all_prefixes(string str) returns string[] {\n    // Implementation here\n}\n```\n\nExample:\n// all_prefixes(\"abc\") should return [\"a\", \"ab\", \"abc\"]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAllPrefixesEmpty() {\n    string[] result = all_prefixes(\"\");\n    string[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty string should return empty array\");\n}\n\n@test:Config { }\nfunction testAllPrefixesLong() {\n    string[] result = all_prefixes(\"asdfgh\");\n    string[] expected = [\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"];\n    test:assertEquals(result, expected, msg = \"Long string prefixes failed\");\n}\n\n@test:Config { }\nfunction testAllPrefixesShort() {\n    string[] result = all_prefixes(\"WWW\");\n    string[] expected = [\"W\", \"WW\", \"WWW\"];\n    test:assertEquals(result, expected, msg = \"Short string prefixes failed\");\n}"
  },
  {
    "id": "request-15",
    "prompt": "Return a string containing space-delimited numbers starting from 0 up to n inclusive.\n\n```ballerina\nfunction string_sequence(n int) returns string {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- string_sequence(0) should return \"0\"\n- string_sequence(5) should return \"0 1 2 3 4 5\"",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStringSequenceZero() {\n    string result = string_sequence(0);\n    test:assertEquals(result, \"0\", msg = \"Failed for n=0\");\n}\n\n@test:Config { }\nfunction testStringSequenceThree() {\n    string result = string_sequence(3);\n    test:assertEquals(result, \"0 1 2 3\", msg = \"Failed for n=3\");\n}\n\n@test:Config { }\nfunction testStringSequenceTen() {\n    string result = string_sequence(10);\n    test:assertEquals(result, \"0 1 2 3 4 5 6 7 8 9 10\", msg = \"Failed for n=10\");\n}"
  },
  {
    "id": "request-16",
    "prompt": "Given a string, find out how many distinct characters (regardless of case) does it consist of.\n\n```ballerina\n// count_distinct_characters(\"xyzXYZ\") should return 3\n// count_distinct_characters(\"Jerry\") should return 4\nfunction count_distinct_characters(string str) returns int {\n\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCountDistinctCharactersEmpty() {\n    int result = count_distinct_characters(\"\");\n    test:assertEquals(result, 0, msg = \"Empty string should return 0\");\n}\n\n@test:Config { }\nfunction testCountDistinctCharactersSimple() {\n    int result = count_distinct_characters(\"abcde\");\n    test:assertEquals(result, 5, msg = \"Simple string should return 5\");\n}\n\n@test:Config { }\nfunction testCountDistinctCharactersMixed() {\n    int result = count_distinct_characters(\"abcdecadeCADE\");\n    test:assertEquals(result, 5, msg = \"Mixed case string should return 5\");\n}\n\n@test:Config { }\nfunction testCountDistinctCharactersSameChar() {\n    int result = count_distinct_characters(\"aaaaAAAAaaaa\");\n    test:assertEquals(result, 1, msg = \"Same character string should return 1\");\n}\n\n@test:Config { }\nfunction testCountDistinctCharactersWithSpaces() {\n    int result = count_distinct_characters(\"Jerry jERRY JeRRRY\");\n    test:assertEquals(result, 5, msg = \"String with spaces should return 5\");\n}"
  },
  {
    "id": "request-17",
    "prompt": "// Parse a string representing musical notes in ASCII format and return an array of integers \n// corresponding to how many beats each note lasts.\n// \n// Legend:\n// 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats  \n// '.|' - quarter note, lasts one beat\n//\n// parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\nfunction parse_music(music_string: string): int[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testParseEmptyString() {\n    int[] result = parse_music(\"\");\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty string should return empty array\");\n}\n\n@test:Config { }\nfunction testParseWholeNotes() {\n    int[] result = parse_music(\"o o o o\");\n    int[] expected = [4, 4, 4, 4];\n    test:assertEquals(result, expected, msg = \"Whole notes should return array of 4s\");\n}\n\n@test:Config { }\nfunction testParseQuarterNotes() {\n    int[] result = parse_music(\".| .| .| .|\");\n    int[] expected = [1, 1, 1, 1];\n    test:assertEquals(result, expected, msg = \"Quarter notes should return array of 1s\");\n}\n\n@test:Config { }\nfunction testParseMixedNotes1() {\n    int[] result = parse_music(\"o| o| .| .| o o o o\");\n    int[] expected = [2, 2, 1, 1, 4, 4, 4, 4];\n    test:assertEquals(result, expected, msg = \"Mixed notes should return correct beat array\");\n}\n\n@test:Config { }\nfunction testParseMixedNotes2() {\n    int[] result = parse_music(\"o| .| o| .| o o| o o|\");\n    int[] expected = [2, 1, 2, 1, 4, 2, 4, 2];\n    test:assertEquals(result, expected, msg = \"Mixed notes should return correct beat array\");\n}"
  },
  {
    "id": "request-18",
    "prompt": "Find how many times a given substring can be found in the original string. Count overlapping cases.\n\n```ballerina\nfunction how_many_times(string str, string substring) returns int {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- how_many_times(\"\", \"a\") should return 0\n- how_many_times(\"aaa\", \"a\") should return 3  \n- how_many_times(\"aaaa\", \"aa\") should return 3",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyStringWithSubstring() {\n    int result = how_many_times(\"\", \"x\");\n    test:assertEquals(result, 0, msg = \"Empty string should return 0\");\n}\n\n@test:Config { }\nfunction testMultipleOccurrences() {\n    int result = how_many_times(\"xyxyxyx\", \"x\");\n    test:assertEquals(result, 4, msg = \"Should count all occurrences of 'x'\");\n}\n\n@test:Config { }\nfunction testOverlappingOccurrences() {\n    int result = how_many_times(\"cacacacac\", \"cac\");\n    test:assertEquals(result, 4, msg = \"Should count overlapping occurrences\");\n}\n\n@test:Config { }\nfunction testSingleOccurrence() {\n    int result = how_many_times(\"john doe\", \"john\");\n    test:assertEquals(result, 1, msg = \"Should find single occurrence\");\n}"
  },
  {
    "id": "request-19",
    "prompt": "// Input is a space-delimited string of numberals from 'zero' to 'nine'.\n// Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n// Return the string with numbers sorted from smallest to largest\n// sort_numbers(\"three one five\") should return \"one three five\"\nfunction sort_numbers(numbers: string) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyString() {\n    test:assertEquals(sort_numbers(\"\"), \"\", msg = \"Empty string test failed\");\n}\n\n@test:Config { }\nfunction testSingleNumber() {\n    test:assertEquals(sort_numbers(\"three\"), \"three\", msg = \"Single number test failed\");\n}\n\n@test:Config { }\nfunction testAlreadySorted() {\n    test:assertEquals(sort_numbers(\"three five nine\"), \"three five nine\", msg = \"Already sorted test failed\");\n}\n\n@test:Config { }\nfunction testMixedNumbers() {\n    test:assertEquals(sort_numbers(\"five zero four seven nine eight\"), \"zero four five seven eight nine\", msg = \"Mixed numbers test failed\");\n}\n\n@test:Config { }\nfunction testReverseSorted() {\n    test:assertEquals(sort_numbers(\"six five four three two one zero\"), \"zero one two three four five six\", msg = \"Reverse sorted test failed\");\n}"
  },
  {
    "id": "request-20",
    "prompt": "From a supplied array of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n\nfunction find_closest_elements(numbers: float[]): [float, float] {\n    // Your implementation here\n}\n\n// find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) should return [2.0, 2.2]\n// find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) should return [2.0, 2.0]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFindClosestElements1() {\n    [float, float] result = find_closest_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]);\n    test:assertEquals(result, [3.9, 4.0], msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testFindClosestElements2() {\n    [float, float] result = find_closest_elements([1.0, 2.0, 5.9, 4.0, 5.0]);\n    test:assertEquals(result, [5.0, 5.9], msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testFindClosestElements3() {\n    [float, float] result = find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]);\n    test:assertEquals(result, [2.0, 2.2], msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testFindClosestElements4() {\n    [float, float] result = find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]);\n    test:assertEquals(result, [2.0, 2.0], msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testFindClosestElements5() {\n    [float, float] result = find_closest_elements([1.1, 2.2, 3.1, 4.1, 5.1]);\n    test:assertEquals(result, [2.2, 3.1], msg = \"Test case 5 failed\");\n}"
  },
  {
    "id": "request-21",
    "prompt": "Given an array of numbers (of at least two elements), apply a linear transform to that array, such that the smallest number will become 0 and the largest will become 1.\n\n```ballerina\nfunction rescale_to_unit(numbers float[]) returns float[] {\n    // Implementation goes here\n}\n```\n\nExample usage:\n```ballerina\nrescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]) // [0.0, 0.25, 0.5, 0.75, 1.0]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testRescaleToUnit1() {\n    float[] result = rescale_to_unit([2.0, 49.9]);\n    float[] expected = [0.0, 1.0];\n    test:assertEquals(result, expected, msg = \"Failed for [2.0, 49.9]\");\n}\n\n@test:Config { }\nfunction testRescaleToUnit2() {\n    float[] result = rescale_to_unit([100.0, 49.9]);\n    float[] expected = [1.0, 0.0];\n    test:assertEquals(result, expected, msg = \"Failed for [100.0, 49.9]\");\n}\n\n@test:Config { }\nfunction testRescaleToUnit3() {\n    float[] result = rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]);\n    float[] expected = [0.0, 0.25, 0.5, 0.75, 1.0];\n    test:assertEquals(result, expected, msg = \"Failed for [1.0, 2.0, 3.0, 4.0, 5.0]\");\n}\n\n@test:Config { }\nfunction testRescaleToUnit4() {\n    float[] result = rescale_to_unit([2.0, 1.0, 5.0, 3.0, 4.0]);\n    float[] expected = [0.25, 0.0, 1.0, 0.5, 0.75];\n    test:assertEquals(result, expected, msg = \"Failed for [2.0, 1.0, 5.0, 3.0, 4.0]\");\n}\n\n@test:Config { }\nfunction testRescaleToUnit5() {\n    float[] result = rescale_to_unit([12.0, 11.0, 15.0, 13.0, 14.0]);\n    float[] expected = [0.25, 0.0, 1.0, 0.5, 0.75];\n    test:assertEquals(result, expected, msg = \"Failed for [12.0, 11.0, 15.0, 13.0, 14.0]\");\n}"
  },
  {
    "id": "request-22",
    "prompt": "Filter the given array of any values to return only the integers.\n\nWrite a function that takes an array of mixed values (strings, numbers, objects, arrays, etc.) and returns a new array containing only the integer values.\n\n```ballerina\nfunction filter_integers(values: any[]) returns int[] {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n```ballerina\n// filter_integers([\"a\", 3.14, 5]) should return [5]\n// filter_integers([1, 2, 3, \"abc\", {}, []]) should return [1, 2, 3]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFilterIntegersEmpty() {\n    int[] result = filter_integers([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array should return empty array\");\n}\n\n@test:Config { }\nfunction testFilterIntegersMixed() {\n    int[] result = filter_integers([4, {}, [], 23.2, 9, \"adasd\"]);\n    int[] expected = [4, 9];\n    test:assertEquals(result, expected, msg = \"Should filter only integers from mixed array\");\n}\n\n@test:Config { }\nfunction testFilterIntegersWithDuplicates() {\n    int[] result = filter_integers([3, \"c\", 3, 3, \"a\", \"b\"]);\n    int[] expected = [3, 3, 3];\n    test:assertEquals(result, expected, msg = \"Should include duplicate integers\");\n}"
  },
  {
    "id": "request-23",
    "prompt": "Return the length of a given string.\n\n// strlen(\"\") should return 0\n// strlen(\"abc\") should return 3\n\nfunction strlen(string str) returns int {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStrlenEmpty() {\n    int result = strlen(\"\");\n    test:assertEquals(result, 0, msg = \"Empty string length should be 0\");\n}\n\n@test:Config { }\nfunction testStrlenSingleChar() {\n    int result = strlen(\"x\");\n    test:assertEquals(result, 1, msg = \"Single character string length should be 1\");\n}\n\n@test:Config { }\nfunction testStrlenMultipleChars() {\n    int result = strlen(\"asdasnakj\");\n    test:assertEquals(result, 9, msg = \"String length should be 9\");\n}"
  },
  {
    "id": "request-24",
    "prompt": "For a given number n, find the largest number that divides n evenly, smaller than n.\n\n// largest_divisor(15) returns 5\nfunction largest_divisor(n int) returns int {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testLargestDivisor() {\n    test:assertEquals(largest_divisor(3), 1, msg = \"largest_divisor(3) should return 1\");\n    test:assertEquals(largest_divisor(7), 1, msg = \"largest_divisor(7) should return 1\");\n    test:assertEquals(largest_divisor(10), 5, msg = \"largest_divisor(10) should return 5\");\n    test:assertEquals(largest_divisor(100), 50, msg = \"largest_divisor(100) should return 50\");\n    test:assertEquals(largest_divisor(49), 7, msg = \"largest_divisor(49) should return 7\");\n}"
  },
  {
    "id": "request-25",
    "prompt": "// Return an array of prime factors of a given integer in order from smallest to largest.\n// Each factor should appear in the array as many times as it appears in the factorization.\n// The input number should equal the product of all factors in the returned array.\n// factorize(8) should return [2, 2, 2]\n// factorize(25) should return [5, 5] \n// factorize(70) should return [2, 5, 7]\n\nfunction factorize(n int) returns int[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFactorize2() {\n    int[] result = factorize(2);\n    int[] expected = [2];\n    test:assertEquals(result, expected, msg = \"factorize(2) failed\");\n}\n\n@test:Config { }\nfunction testFactorize4() {\n    int[] result = factorize(4);\n    int[] expected = [2, 2];\n    test:assertEquals(result, expected, msg = \"factorize(4) failed\");\n}\n\n@test:Config { }\nfunction testFactorize8() {\n    int[] result = factorize(8);\n    int[] expected = [2, 2, 2];\n    test:assertEquals(result, expected, msg = \"factorize(8) failed\");\n}\n\n@test:Config { }\nfunction testFactorize57() {\n    int[] result = factorize(57);\n    int[] expected = [3, 19];\n    test:assertEquals(result, expected, msg = \"factorize(57) failed\");\n}\n\n@test:Config { }\nfunction testFactorize3249() {\n    int[] result = factorize(3249);\n    int[] expected = [3, 3, 19, 19];\n    test:assertEquals(result, expected, msg = \"factorize(3249) failed\");\n}\n\n@test:Config { }\nfunction testFactorize185193() {\n    int[] result = factorize(185193);\n    int[] expected = [3, 3, 3, 19, 19, 19];\n    test:assertEquals(result, expected, msg = \"factorize(185193) failed\");\n}\n\n@test:Config { }\nfunction testFactorize20577() {\n    int[] result = factorize(20577);\n    int[] expected = [3, 19, 19, 19];\n    test:assertEquals(result, expected, msg = \"factorize(20577) failed\");\n}\n\n@test:Config { }\nfunction testFactorize18() {\n    int[] result = factorize(18);\n    int[] expected = [2, 3, 3];\n    test:assertEquals(result, expected, msg = \"factorize(18) failed\");\n}"
  },
  {
    "id": "request-26",
    "prompt": "From an array of integers, remove all elements that occur more than once. Keep the order of elements left the same as in the input.\n\nFor example:\n// remove_duplicates([1, 2, 3, 2, 4]) should return [1, 3, 4]\n\nfunction remove_duplicates(numbers: int[]): int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testRemoveDuplicatesEmpty() {\n    int[] result = remove_duplicates([]);\n    test:assertEquals(result, [], msg = \"Empty array test failed\");\n}\n\n@test:Config {}\nfunction testRemoveDuplicatesNoDuplicates() {\n    int[] result = remove_duplicates([1, 2, 3, 4]);\n    test:assertEquals(result, [1, 2, 3, 4], msg = \"No duplicates test failed\");\n}\n\n@test:Config {}\nfunction testRemoveDuplicatesWithDuplicates() {\n    int[] result = remove_duplicates([1, 2, 3, 2, 4, 3, 5]);\n    test:assertEquals(result, [1, 4, 5], msg = \"Remove duplicates test failed\");\n}"
  },
  {
    "id": "request-27",
    "prompt": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n\n```ballerina\n// flip_case(\"Hello\") returns \"hELLO\"\nfunction flip_case(string str) returns string {\n    // Your implementation here\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFlipCaseEmpty() {\n    string result = flip_case(\"\");\n    test:assertEquals(result, \"\", msg = \"Empty string test failed\");\n}\n\n@test:Config { }\nfunction testFlipCaseWithSpecialChar() {\n    string result = flip_case(\"Hello!\");\n    test:assertEquals(result, \"hELLO!\", msg = \"String with special character test failed\");\n}\n\n@test:Config { }\nfunction testFlipCaseLongString() {\n    string result = flip_case(\"These violent delights have violent ends\");\n    test:assertEquals(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\", msg = \"Long string test failed\");\n}"
  },
  {
    "id": "request-28",
    "prompt": "Write a function that takes an array of strings and concatenates them into a single string.\n\n// concatenate([])\n// \"\"\n// concatenate([\"a\", \"b\", \"c\"])\n// \"abc\"\n\nfunction concatenate(strings: string[]) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testConcatenateEmpty() {\n    string result = concatenate([]);\n    test:assertEquals(result, \"\", msg = \"Empty array should return empty string\");\n}\n\n@test:Config { }\nfunction testConcatenateThreeStrings() {\n    string result = concatenate([\"x\", \"y\", \"z\"]);\n    test:assertEquals(result, \"xyz\", msg = \"Three strings should be concatenated\");\n}\n\n@test:Config { }\nfunction testConcatenateFiveStrings() {\n    string result = concatenate([\"x\", \"y\", \"z\", \"w\", \"k\"]);\n    test:assertEquals(result, \"xyzwk\", msg = \"Five strings should be concatenated\");\n}"
  },
  {
    "id": "request-29",
    "prompt": "Filter an input array of strings only for ones that start with a given prefix.\n\n// filter_by_prefix([], \"a\") should return []\n// filter_by_prefix([\"abc\", \"bcd\", \"cde\", \"array\"], \"a\") should return [\"abc\", \"array\"]\n\nfunction filter_by_prefix(strings: string[], prefix: string) returns string[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFilterByPrefixEmpty() {\n    string[] result = filter_by_prefix([], \"john\");\n    string[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testFilterByPrefixWithMatches() {\n    string[] result = filter_by_prefix([\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"], \"xxx\");\n    string[] expected = [\"xxx\", \"xxxAAA\", \"xxx\"];\n    test:assertEquals(result, expected, msg = \"Filter by prefix test failed\");\n}"
  },
  {
    "id": "request-30",
    "prompt": "Return only positive numbers in the array.\n\n```ballerina\nfunction get_positive(l int[]) returns int[] {\n    // Implementation needed\n}\n```\n\nExample usage:\n```ballerina\n// get_positive([-1, 2, -4, 5, 6]) should return [2, 5, 6]\n// get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) should return [5, 3, 2, 3, 9, 123, 1]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGetPositiveBasic() {\n    int[] result = get_positive([-1, -2, 4, 5, 6]);\n    int[] expected = [4, 5, 6];\n    test:assertEquals(result, expected, msg = \"Failed for basic positive filtering\");\n}\n\n@test:Config { }\nfunction testGetPositiveMixed() {\n    int[] result = get_positive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]);\n    int[] expected = [5, 3, 2, 3, 3, 9, 123, 1];\n    test:assertEquals(result, expected, msg = \"Failed for mixed array with zero\");\n}\n\n@test:Config { }\nfunction testGetPositiveAllNegative() {\n    int[] result = get_positive([-1, -2]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for all negative numbers\");\n}\n\n@test:Config { }\nfunction testGetPositiveEmptyArray() {\n    int[] result = get_positive([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for empty array\");\n}"
  },
  {
    "id": "request-31",
    "prompt": "Write a function that returns true if a given number is prime, and false otherwise.\n\n```ballerina\nfunction is_prime(n int) returns boolean {\n    // Your implementation here\n}\n```\n\nExample calls:\n// is_prime(6) -> false\n// is_prime(101) -> true\n// is_prime(11) -> true\n// is_prime(13441) -> true\n// is_prime(61) -> true\n// is_prime(4) -> false\n// is_prime(1) -> false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsPrime() {\n    test:assertFalse(is_prime(6), msg = \"6 should not be prime\");\n    test:assertTrue(is_prime(101), msg = \"101 should be prime\");\n    test:assertTrue(is_prime(11), msg = \"11 should be prime\");\n    test:assertTrue(is_prime(13441), msg = \"13441 should be prime\");\n    test:assertTrue(is_prime(61), msg = \"61 should be prime\");\n    test:assertFalse(is_prime(4), msg = \"4 should not be prime\");\n    test:assertFalse(is_prime(1), msg = \"1 should not be prime\");\n    test:assertTrue(is_prime(5), msg = \"5 should be prime\");\n    test:assertTrue(is_prime(17), msg = \"17 should be prime\");\n    test:assertFalse(is_prime(85), msg = \"85 should not be prime\");\n    test:assertFalse(is_prime(77), msg = \"77 should not be prime\");\n    test:assertFalse(is_prime(255379), msg = \"255379 should not be prime\");\n}"
  },
  {
    "id": "request-32",
    "prompt": "Write a function that takes an array of numbers and returns a modified array where:\n- Elements at indices that are NOT divisible by three remain in their original positions\n- Elements at indices that ARE divisible by three (0, 3, 6, 9, etc.) are sorted among themselves and placed back at those same divisible-by-three positions\n\nFunction signature: `function sort_third(l: int[]): int[]`\n\nExamples:\n- sort_third([1, 2, 3]) should return [1, 2, 3]\n- sort_third([5, 6, 3, 4, 8, 9, 2]) should return [2, 6, 3, 4, 8, 9, 5]",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testSortThird1() {\n    int[] result = sort_third([5, 6, 3, 4, 8, 9, 2]);\n    int[] expected = [2, 6, 3, 4, 8, 9, 5];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config {}\nfunction testSortThird2() {\n    int[] result = sort_third([5, 8, 3, 4, 6, 9, 2]);\n    int[] expected = [2, 8, 3, 4, 6, 9, 5];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config {}\nfunction testSortThird3() {\n    int[] result = sort_third([5, 6, 9, 4, 8, 3, 2]);\n    int[] expected = [2, 6, 9, 4, 8, 3, 5];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config {}\nfunction testSortThird4() {\n    int[] result = sort_third([5, 6, 3, 4, 8, 9, 2, 1]);\n    int[] expected = [2, 6, 3, 4, 8, 9, 5, 1];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}"
  },
  {
    "id": "request-33",
    "prompt": "Write a function that takes an array of numbers and returns a new array containing only the unique elements, sorted in ascending order.\n\nfunction unique(l: int[]): int[] {\n    // Your implementation here\n}\n\n// Example usage:\n// unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) should return [0, 2, 3, 5, 9, 123]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testUnique() {\n    int[] result = unique([5, 3, 5, 2, 3, 3, 9, 0, 123]);\n    int[] expected = [0, 2, 3, 5, 9, 123];\n    test:assertEquals(result, expected, msg = \"Unique function test failed\");\n}"
  },
  {
    "id": "request-34",
    "prompt": "Write a function that returns the maximum element in the given array.\n\n```ballerina\nfunction max_element(l int[]) returns int {\n    // Your implementation here\n}\n```\n\nExample usage:\n```ballerina\nmax_element([1, 2, 3]) // returns 3\nmax_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) // returns 123\n```",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testMaxElement1() {\n    int result = max_element([1, 2, 3]);\n    test:assertEquals(result, 3, msg = \"Failed for array [1, 2, 3]\");\n}\n\n@test:Config {}\nfunction testMaxElement2() {\n    int result = max_element([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]);\n    test:assertEquals(result, 124, msg = \"Failed for array [5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]\");\n}"
  },
  {
    "id": "request-35",
    "prompt": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\nfunction fizz_buzz(n int) returns int {\n    // Your implementation here\n}\n\n// Example usage:\n// fizz_buzz(50) // returns 0\n// fizz_buzz(78) // returns 2  \n// fizz_buzz(79) // returns 3",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testFizzBuzz1() {\n    test:assertEquals(fizz_buzz(50), 0, msg = \"fizz_buzz(50) should return 0\");\n}\n\n@test:Config {}\nfunction testFizzBuzz2() {\n    test:assertEquals(fizz_buzz(78), 2, msg = \"fizz_buzz(78) should return 2\");\n}\n\n@test:Config {}\nfunction testFizzBuzz3() {\n    test:assertEquals(fizz_buzz(79), 3, msg = \"fizz_buzz(79) should return 3\");\n}\n\n@test:Config {}\nfunction testFizzBuzz4() {\n    test:assertEquals(fizz_buzz(100), 3, msg = \"fizz_buzz(100) should return 3\");\n}\n\n@test:Config {}\nfunction testFizzBuzz5() {\n    test:assertEquals(fizz_buzz(200), 6, msg = \"fizz_buzz(200) should return 6\");\n}\n\n@test:Config {}\nfunction testFizzBuzz6() {\n    test:assertEquals(fizz_buzz(4000), 192, msg = \"fizz_buzz(4000) should return 192\");\n}\n\n@test:Config {}\nfunction testFizzBuzz7() {\n    test:assertEquals(fizz_buzz(10000), 639, msg = \"fizz_buzz(10000) should return 639\");\n}\n\n@test:Config {}\nfunction testFizzBuzz8() {\n    test:assertEquals(fizz_buzz(100000), 8026, msg = \"fizz_buzz(100000) should return 8026\");\n}"
  },
  {
    "id": "request-36",
    "prompt": "Write a function that takes an array of numbers and returns a new array where:\n- Values at odd indices (1, 3, 5, ...) remain in their original positions\n- Values at even indices (0, 2, 4, ...) are sorted in ascending order but stay at even positions\n\nFunction signature: `function sortEven(l int[]) returns int[]`\n\nExamples:\n// sortEven([1, 2, 3]) returns [1, 2, 3]\n// sortEven([5, 6, 3, 4]) returns [3, 6, 5, 4]",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testSortEven1() {\n    int[] result = sortEven([1, 2, 3]);\n    int[] expected = [1, 2, 3];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config {}\nfunction testSortEven2() {\n    int[] result = sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]);\n    int[] expected = [-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config {}\nfunction testSortEven3() {\n    int[] result = sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]);\n    int[] expected = [-12, 8, 3, 4, 5, 2, 12, 11, 23, -10];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}"
  },
  {
    "id": "request-37",
    "prompt": "Write a function that returns the n-th number that is both a Fibonacci number and prime.\n\nfunction prime_fib(n int) returns int\n\n// prime_fib(1) returns 2\n// prime_fib(2) returns 3\n// prime_fib(3) returns 5\n// prime_fib(4) returns 13\n// prime_fib(5) returns 89",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testPrimeFib1() {\n    int result = prime_fib(1);\n    test:assertEquals(result, 2, msg = \"prime_fib(1) should return 2\");\n}\n\n@test:Config { }\nfunction testPrimeFib2() {\n    int result = prime_fib(2);\n    test:assertEquals(result, 3, msg = \"prime_fib(2) should return 3\");\n}\n\n@test:Config { }\nfunction testPrimeFib3() {\n    int result = prime_fib(3);\n    test:assertEquals(result, 5, msg = \"prime_fib(3) should return 5\");\n}\n\n@test:Config { }\nfunction testPrimeFib4() {\n    int result = prime_fib(4);\n    test:assertEquals(result, 13, msg = \"prime_fib(4) should return 13\");\n}\n\n@test:Config { }\nfunction testPrimeFib5() {\n    int result = prime_fib(5);\n    test:assertEquals(result, 89, msg = \"prime_fib(5) should return 89\");\n}\n\n@test:Config { }\nfunction testPrimeFib6() {\n    int result = prime_fib(6);\n    test:assertEquals(result, 233, msg = \"prime_fib(6) should return 233\");\n}\n\n@test:Config { }\nfunction testPrimeFib7() {\n    int result = prime_fib(7);\n    test:assertEquals(result, 1597, msg = \"prime_fib(7) should return 1597\");\n}\n\n@test:Config { }\nfunction testPrimeFib8() {\n    int result = prime_fib(8);\n    test:assertEquals(result, 28657, msg = \"prime_fib(8) should return 28657\");\n}\n\n@test:Config { }\nfunction testPrimeFib9() {\n    int result = prime_fib(9);\n    test:assertEquals(result, 514229, msg = \"prime_fib(9) should return 514229\");\n}\n\n@test:Config { }\nfunction testPrimeFib10() {\n    int result = prime_fib(10);\n    test:assertEquals(result, 433494437, msg = \"prime_fib(10) should return 433494437\");\n}"
  },
  {
    "id": "request-38",
    "prompt": "Write a function that takes an array of integers as input and returns true if there are three distinct elements in the array that sum to zero, and false otherwise.\n\n```ballerina\nfunction triples_sum_to_zero(l int[]) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n// triples_sum_to_zero([1, 3, 5, 0]) returns false\n// triples_sum_to_zero([1, 3, -2, 1]) returns true\n// triples_sum_to_zero([1, 2, 3, 7]) returns false\n// triples_sum_to_zero([2, 4, -5, 3, 9, 7]) returns true\n// triples_sum_to_zero([1]) returns false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTriplesSum1() {\n    boolean result = triples_sum_to_zero([1, 3, 5, 0]);\n    test:assertEquals(result, false, msg = \"Test case [1, 3, 5, 0] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum2() {\n    boolean result = triples_sum_to_zero([1, 3, 5, -1]);\n    test:assertEquals(result, false, msg = \"Test case [1, 3, 5, -1] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum3() {\n    boolean result = triples_sum_to_zero([1, 3, -2, 1]);\n    test:assertEquals(result, true, msg = \"Test case [1, 3, -2, 1] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum4() {\n    boolean result = triples_sum_to_zero([1, 2, 3, 7]);\n    test:assertEquals(result, false, msg = \"Test case [1, 2, 3, 7] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum5() {\n    boolean result = triples_sum_to_zero([1, 2, 5, 7]);\n    test:assertEquals(result, false, msg = \"Test case [1, 2, 5, 7] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum6() {\n    boolean result = triples_sum_to_zero([2, 4, -5, 3, 9, 7]);\n    test:assertEquals(result, true, msg = \"Test case [2, 4, -5, 3, 9, 7] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum7() {\n    boolean result = triples_sum_to_zero([1]);\n    test:assertEquals(result, false, msg = \"Test case [1] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum8() {\n    boolean result = triples_sum_to_zero([1, 3, 5, -100]);\n    test:assertEquals(result, false, msg = \"Test case [1, 3, 5, -100] failed\");\n}\n\n@test:Config { }\nfunction testTriplesSum9() {\n    boolean result = triples_sum_to_zero([100, 3, 5, -100]);\n    test:assertEquals(result, false, msg = \"Test case [100, 3, 5, -100] failed\");\n}"
  },
  {
    "id": "request-39",
    "prompt": "Imagine a road that's a perfectly straight infinitely long line. n cars are driving left to right; simultaneously, a different set of n cars are driving right to left. The two sets of cars start out being very far from each other. All cars move at the same speed. Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide. Write a function that outputs the number of such collisions.\n\nfunction car_race_collision(n int) returns int {\n    // Your implementation here\n}\n\n// Expected function calls:\n// car_race_collision(2) // returns 4\n// car_race_collision(3) // returns 9\n// car_race_collision(4) // returns 16\n// car_race_collision(8) // returns 64\n// car_race_collision(10) // returns 100",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCarRaceCollision2() {\n    int result = car_race_collision(2);\n    test:assertEquals(result, 4, msg = \"car_race_collision(2) should return 4\");\n}\n\n@test:Config { }\nfunction testCarRaceCollision3() {\n    int result = car_race_collision(3);\n    test:assertEquals(result, 9, msg = \"car_race_collision(3) should return 9\");\n}\n\n@test:Config { }\nfunction testCarRaceCollision4() {\n    int result = car_race_collision(4);\n    test:assertEquals(result, 16, msg = \"car_race_collision(4) should return 16\");\n}\n\n@test:Config { }\nfunction testCarRaceCollision8() {\n    int result = car_race_collision(8);\n    test:assertEquals(result, 64, msg = \"car_race_collision(8) should return 64\");\n}\n\n@test:Config { }\nfunction testCarRaceCollision10() {\n    int result = car_race_collision(10);\n    test:assertEquals(result, 100, msg = \"car_race_collision(10) should return 100\");\n}"
  },
  {
    "id": "request-40",
    "prompt": "Write a function that takes an array of numbers and returns a new array with each element incremented by 1.\n\n```ballerina\nfunction incr_list(l int[]) returns int[] {\n    // Your implementation here\n}\n```\n\nExample usage:\n```ballerina\nincr_list([1, 2, 3]) // Returns [2, 3, 4]\nincr_list([5, 3, 5, 2, 3, 3, 9, 0, 123]) // Returns [6, 4, 6, 3, 4, 4, 10, 1, 124]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIncrListEmpty() {\n    int[] result = incr_list([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testIncrListSimple() {\n    int[] result = incr_list([3, 2, 1]);\n    int[] expected = [4, 3, 2];\n    test:assertEquals(result, expected, msg = \"Simple array test failed\");\n}\n\n@test:Config { }\nfunction testIncrListLarge() {\n    int[] result = incr_list([5, 2, 5, 2, 3, 3, 9, 0, 123]);\n    int[] expected = [6, 3, 6, 3, 4, 4, 10, 1, 124];\n    test:assertEquals(result, expected, msg = \"Large array test failed\");\n}"
  },
  {
    "id": "request-41",
    "prompt": "Write a function that takes an array of integers as input and returns true if there are two distinct elements in the array that sum to zero, and false otherwise.\n\n```ballerina\nfunction pairs_sum_to_zero(l int[]) returns boolean {\n    // Your implementation here\n}\n```\n\n// pairs_sum_to_zero([1, 3, 5, 0]) → false\n// pairs_sum_to_zero([1, 3, -2, 1]) → false  \n// pairs_sum_to_zero([1, 2, 3, 7]) → false\n// pairs_sum_to_zero([2, 4, -5, 3, 5, 7]) → true\n// pairs_sum_to_zero([1]) → false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testPairsSumToZero1() {\n    test:assertFalse(pairs_sum_to_zero([1, 3, 5, 0]), msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero2() {\n    test:assertFalse(pairs_sum_to_zero([1, 3, -2, 1]), msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero3() {\n    test:assertFalse(pairs_sum_to_zero([1, 2, 3, 7]), msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero4() {\n    test:assertTrue(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]), msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero5() {\n    test:assertFalse(pairs_sum_to_zero([1]), msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero6() {\n    test:assertTrue(pairs_sum_to_zero([-3, 9, -1, 3, 2, 30]), msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero7() {\n    test:assertTrue(pairs_sum_to_zero([-3, 9, -1, 3, 2, 31]), msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero8() {\n    test:assertFalse(pairs_sum_to_zero([-3, 9, -1, 4, 2, 30]), msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testPairsSumToZero9() {\n    test:assertFalse(pairs_sum_to_zero([-3, 9, -1, 4, 2, 31]), msg = \"Test case 9 failed\");\n}"
  },
  {
    "id": "request-42",
    "prompt": "Change the numerical base of input number x to the specified base. Return the string representation after the conversion. The base numbers are less than 10.\n\n// change_base(8, 3) should return \"22\"\n// change_base(8, 2) should return \"1000\"  \n// change_base(7, 2) should return \"111\"\n\nfunction change_base(x int, base int) returns string {",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testChangeBase1() {\n    test:assertEquals(change_base(8, 3), \"22\", msg = \"change_base(8, 3) should return '22'\");\n}\n\n@test:Config { }\nfunction testChangeBase2() {\n    test:assertEquals(change_base(9, 3), \"100\", msg = \"change_base(9, 3) should return '100'\");\n}\n\n@test:Config { }\nfunction testChangeBase3() {\n    test:assertEquals(change_base(234, 2), \"11101010\", msg = \"change_base(234, 2) should return '11101010'\");\n}\n\n@test:Config { }\nfunction testChangeBase4() {\n    test:assertEquals(change_base(16, 2), \"10000\", msg = \"change_base(16, 2) should return '10000'\");\n}\n\n@test:Config { }\nfunction testChangeBase5() {\n    test:assertEquals(change_base(8, 2), \"1000\", msg = \"change_base(8, 2) should return '1000'\");\n}\n\n@test:Config { }\nfunction testChangeBase6() {\n    test:assertEquals(change_base(7, 2), \"111\", msg = \"change_base(7, 2) should return '111'\");\n}\n\n@test:Config { }\nfunction testChangeBase7() {\n    test:assertEquals(change_base(2, 3), \"2\", msg = \"change_base(2, 3) should return '2'\");\n}\n\n@test:Config { }\nfunction testChangeBase8() {\n    test:assertEquals(change_base(3, 4), \"3\", msg = \"change_base(3, 4) should return '3'\");\n}\n\n@test:Config { }\nfunction testChangeBase9() {\n    test:assertEquals(change_base(4, 5), \"4\", msg = \"change_base(4, 5) should return '4'\");\n}\n\n@test:Config { }\nfunction testChangeBase10() {\n    test:assertEquals(change_base(5, 6), \"5\", msg = \"change_base(5, 6) should return '5'\");\n}\n\n@test:Config { }\nfunction testChangeBase11() {\n    test:assertEquals(change_base(6, 7), \"6\", msg = \"change_base(6, 7) should return '6'\");\n}\n\n@test:Config { }\nfunction testChangeBase12() {\n    test:assertEquals(change_base(7, 8), \"7\", msg = \"change_base(7, 8) should return '7'\");\n}"
  },
  {
    "id": "request-43",
    "prompt": "Given the length of a side (base) and height, return the area of a triangle.\n\n```ballerina\n// triangle_area(5, 3) should return 7.5\nfunction triangle_area(a float, h float) returns float {\n    // Your implementation here\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTriangleArea1() {\n    float result = triangle_area(5, 3);\n    test:assertEquals(result, 7.5, msg = \"Triangle area calculation failed for base=5, height=3\");\n}\n\n@test:Config { }\nfunction testTriangleArea2() {\n    float result = triangle_area(2, 2);\n    test:assertEquals(result, 2.0, msg = \"Triangle area calculation failed for base=2, height=2\");\n}\n\n@test:Config { }\nfunction testTriangleArea3() {\n    float result = triangle_area(10, 8);\n    test:assertEquals(result, 40.0, msg = \"Triangle area calculation failed for base=10, height=8\");\n}"
  },
  {
    "id": "request-44",
    "prompt": "The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n- fib4(0) -> 0\n- fib4(1) -> 0  \n- fib4(2) -> 2\n- fib4(3) -> 0\n- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.\n\nfunction fib4(n int) returns int {\n    // Your implementation here\n}\n\n// fib4(5) -> 4\n// fib4(6) -> 8\n// fib4(7) -> 14",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFib4_5() {\n    int result = fib4(5);\n    test:assertEquals(result, 4, msg = \"fib4(5) should return 4\");\n}\n\n@test:Config { }\nfunction testFib4_8() {\n    int result = fib4(8);\n    test:assertEquals(result, 28, msg = \"fib4(8) should return 28\");\n}\n\n@test:Config { }\nfunction testFib4_10() {\n    int result = fib4(10);\n    test:assertEquals(result, 104, msg = \"fib4(10) should return 104\");\n}\n\n@test:Config { }\nfunction testFib4_12() {\n    int result = fib4(12);\n    test:assertEquals(result, 386, msg = \"fib4(12) should return 386\");\n}"
  },
  {
    "id": "request-45",
    "prompt": "Write a function that returns the median of elements in the array l.\n\nExamples:\n// median([3, 1, 2, 4, 5]) should return 3\n// median([-10, 4, 6, 1000, 10, 20]) should return 8.0\n\nfunction median(l: float[]): float {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMedianOddLength() {\n    float result = median([3, 1, 2, 4, 5]);\n    test:assertEquals(result, 3.0, msg = \"Median of [3, 1, 2, 4, 5] should be 3\");\n}\n\n@test:Config { }\nfunction testMedianEvenLength() {\n    float result = median([-10, 4, 6, 1000, 10, 20]);\n    test:assertEquals(result, 8.0, msg = \"Median of [-10, 4, 6, 1000, 10, 20] should be 8.0\");\n}\n\n@test:Config { }\nfunction testMedianSingleElement() {\n    float result = median([5]);\n    test:assertEquals(result, 5.0, msg = \"Median of [5] should be 5\");\n}\n\n@test:Config { }\nfunction testMedianTwoElements() {\n    float result = median([6, 5]);\n    test:assertEquals(result, 5.5, msg = \"Median of [6, 5] should be 5.5\");\n}\n\n@test:Config { }\nfunction testMedianOddLengthSeven() {\n    float result = median([8, 1, 3, 9, 9, 2, 7]);\n    test:assertEquals(result, 7.0, msg = \"Median of [8, 1, 3, 9, 9, 2, 7] should be 7\");\n}"
  },
  {
    "id": "request-46",
    "prompt": "Write a function that checks if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward.\n\n```ballerina\nfunction is_palindrome(text string) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- is_palindrome(\"\") should return true\n- is_palindrome(\"aba\") should return true  \n- is_palindrome(\"aaaaa\") should return true\n- is_palindrome(\"zbcd\") should return false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyString() {\n    boolean result = is_palindrome(\"\");\n    test:assertTrue(result, msg = \"Empty string should be a palindrome\");\n}\n\n@test:Config { }\nfunction testPalindromeAba() {\n    boolean result = is_palindrome(\"aba\");\n    test:assertTrue(result, msg = \"aba should be a palindrome\");\n}\n\n@test:Config { }\nfunction testPalindromeAaaaa() {\n    boolean result = is_palindrome(\"aaaaa\");\n    test:assertTrue(result, msg = \"aaaaa should be a palindrome\");\n}\n\n@test:Config { }\nfunction testNotPalindromeZbcd() {\n    boolean result = is_palindrome(\"zbcd\");\n    test:assertFalse(result, msg = \"zbcd should not be a palindrome\");\n}\n\n@test:Config { }\nfunction testPalindromeXywyx() {\n    boolean result = is_palindrome(\"xywyx\");\n    test:assertTrue(result, msg = \"xywyx should be a palindrome\");\n}\n\n@test:Config { }\nfunction testNotPalindromeXywyz() {\n    boolean result = is_palindrome(\"xywyz\");\n    test:assertFalse(result, msg = \"xywyz should not be a palindrome\");\n}\n\n@test:Config { }\nfunction testNotPalindromeXywzx() {\n    boolean result = is_palindrome(\"xywzx\");\n    test:assertFalse(result, msg = \"xywzx should not be a palindrome\");\n}"
  },
  {
    "id": "request-47",
    "prompt": "Calculate 2^n modulo p (be careful with large numbers to avoid overflow).\n\n// modp(3, 5) → 3\n// modp(1101, 101) → 2  \n// modp(0, 101) → 1\n// modp(3, 11) → 8\n// modp(100, 101) → 1\n\nfunction modp(n int, p int) returns int {\n    \n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testModp1() {\n    int result = modp(3, 5);\n    test:assertEquals(result, 3, msg = \"modp(3, 5) should return 3\");\n}\n\n@test:Config { }\nfunction testModp2() {\n    int result = modp(1101, 101);\n    test:assertEquals(result, 2, msg = \"modp(1101, 101) should return 2\");\n}\n\n@test:Config { }\nfunction testModp3() {\n    int result = modp(0, 101);\n    test:assertEquals(result, 1, msg = \"modp(0, 101) should return 1\");\n}\n\n@test:Config { }\nfunction testModp4() {\n    int result = modp(3, 11);\n    test:assertEquals(result, 8, msg = \"modp(3, 11) should return 8\");\n}\n\n@test:Config { }\nfunction testModp5() {\n    int result = modp(100, 101);\n    test:assertEquals(result, 1, msg = \"modp(100, 101) should return 1\");\n}\n\n@test:Config { }\nfunction testModp6() {\n    int result = modp(30, 5);\n    test:assertEquals(result, 4, msg = \"modp(30, 5) should return 4\");\n}\n\n@test:Config { }\nfunction testModp7() {\n    int result = modp(31, 5);\n    test:assertEquals(result, 3, msg = \"modp(31, 5) should return 3\");\n}"
  },
  {
    "id": "request-48",
    "prompt": "Write a function that takes a string and returns a new string with all vowels removed. Vowels are considered to be 'a', 'e', 'i', 'o', 'u' in both uppercase and lowercase.\n\nfunction remove_vowels(text: string): string {\n\n// remove_vowels(\"\") → \"\"\n// remove_vowels(\"abcdef\") → \"bcdf\"  \n// remove_vowels(\"aaaaa\") → \"\"\n// remove_vowels(\"aaBAA\") → \"B\"\n// remove_vowels(\"zbcd\") → \"zbcd\"",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testRemoveVowelsEmpty() {\n    string result = remove_vowels(\"\");\n    test:assertEquals(result, \"\", msg = \"Empty string test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsWithNewline() {\n    string result = remove_vowels(\"abcdef\\nghijklm\");\n    test:assertEquals(result, \"bcdf\\nghjklm\", msg = \"String with newline test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsReversed() {\n    string result = remove_vowels(\"fedcba\");\n    test:assertEquals(result, \"fdcb\", msg = \"Reversed string test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsAllVowels() {\n    string result = remove_vowels(\"eeeee\");\n    test:assertEquals(result, \"\", msg = \"All vowels test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsMixed() {\n    string result = remove_vowels(\"acBAA\");\n    test:assertEquals(result, \"cB\", msg = \"Mixed case test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsUppercase() {\n    string result = remove_vowels(\"EcBOO\");\n    test:assertEquals(result, \"cB\", msg = \"Uppercase vowels test failed\");\n}\n\n@test:Config { }\nfunction testRemoveVowelsNoVowels() {\n    string result = remove_vowels(\"ybcd\");\n    test:assertEquals(result, \"ybcd\", msg = \"No vowels test failed\");\n}"
  },
  {
    "id": "request-49",
    "prompt": "Write a function that checks if all numbers in an array are below a given threshold. The function should return true if all numbers in the array are strictly less than the threshold, and false otherwise.\n\n```ballerina\nfunction below_threshold(l: int[], t: int) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- below_threshold([1, 2, 4, 10], 100) should return true\n- below_threshold([1, 20, 4, 10], 5) should return false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testBelowThreshold1() {\n    boolean result = below_threshold([1, 2, 4, 10], 100);\n    test:assertTrue(result, msg = \"All numbers should be below threshold 100\");\n}\n\n@test:Config { }\nfunction testBelowThreshold2() {\n    boolean result = below_threshold([1, 20, 4, 10], 5);\n    test:assertFalse(result, msg = \"Not all numbers should be below threshold 5\");\n}\n\n@test:Config { }\nfunction testBelowThreshold3() {\n    boolean result = below_threshold([1, 20, 4, 10], 21);\n    test:assertTrue(result, msg = \"All numbers should be below threshold 21\");\n}\n\n@test:Config { }\nfunction testBelowThreshold4() {\n    boolean result = below_threshold([1, 20, 4, 10], 22);\n    test:assertTrue(result, msg = \"All numbers should be below threshold 22\");\n}\n\n@test:Config { }\nfunction testBelowThreshold5() {\n    boolean result = below_threshold([1, 8, 4, 10], 11);\n    test:assertTrue(result, msg = \"All numbers should be below threshold 11\");\n}\n\n@test:Config { }\nfunction testBelowThreshold6() {\n    boolean result = below_threshold([1, 8, 4, 10], 10);\n    test:assertFalse(result, msg = \"Not all numbers should be below threshold 10\");\n}"
  },
  {
    "id": "request-50",
    "prompt": "Add two numbers x and y\n\nfunction add(int x, int y) returns int {\n    // Implementation goes here\n}\n\n// Expected usage:\n// add(2, 3) should return 5\n// add(5, 7) should return 12",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAdd() {\n    test:assertEquals(add(0, 1), 1, msg = \"add(0, 1) should return 1\");\n    test:assertEquals(add(1, 0), 1, msg = \"add(1, 0) should return 1\");\n    test:assertEquals(add(2, 3), 5, msg = \"add(2, 3) should return 5\");\n    test:assertEquals(add(5, 7), 12, msg = \"add(5, 7) should return 12\");\n    test:assertEquals(add(7, 5), 12, msg = \"add(7, 5) should return 12\");\n}"
  },
  {
    "id": "request-51",
    "prompt": "Check if two words have the same characters (same unique characters, ignoring frequency and order).\n\nWrite a function `same_chars` that takes two strings and returns true if they contain exactly the same set of unique characters, false otherwise.\n\n```ballerina\nfunction same_chars(s0 string, s1 string) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") should return true\n- same_chars(\"abcd\", \"dddddddabc\") should return true  \n- same_chars(\"dddddddabc\", \"abcd\") should return true\n- same_chars(\"eabcd\", \"dddddddabc\") should return false\n- same_chars(\"abcd\", \"dddddddabce\") should return false\n- same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") should return false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSameChars1() {\n    boolean result = same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\");\n    test:assertTrue(result, msg = \"Should return true for same character sets\");\n}\n\n@test:Config { }\nfunction testSameChars2() {\n    boolean result = same_chars(\"abcd\", \"dddddddabc\");\n    test:assertTrue(result, msg = \"Should return true for same character sets\");\n}\n\n@test:Config { }\nfunction testSameChars3() {\n    boolean result = same_chars(\"dddddddabc\", \"abcd\");\n    test:assertTrue(result, msg = \"Should return true for same character sets\");\n}\n\n@test:Config { }\nfunction testSameChars4() {\n    boolean result = same_chars(\"eabcd\", \"dddddddabc\");\n    test:assertFalse(result, msg = \"Should return false for different character sets\");\n}\n\n@test:Config { }\nfunction testSameChars5() {\n    boolean result = same_chars(\"abcd\", \"dddddddabcf\");\n    test:assertFalse(result, msg = \"Should return false for different character sets\");\n}\n\n@test:Config { }\nfunction testSameChars6() {\n    boolean result = same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\");\n    test:assertFalse(result, msg = \"Should return false for different character sets\");\n}\n\n@test:Config { }\nfunction testSameChars7() {\n    boolean result = same_chars(\"aabb\", \"aaccc\");\n    test:assertFalse(result, msg = \"Should return false for different character sets\");\n}"
  },
  {
    "id": "request-52",
    "prompt": "Write a function that returns the n-th Fibonacci number.\n\n```ballerina\nfunction fib(n int) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n// fib(10) returns 55\n// fib(1) returns 1  \n// fib(8) returns 21",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFib10() {\n    int result = fib(10);\n    test:assertEquals(result, 55, msg = \"fib(10) should return 55\");\n}\n\n@test:Config { }\nfunction testFib1() {\n    int result = fib(1);\n    test:assertEquals(result, 1, msg = \"fib(1) should return 1\");\n}\n\n@test:Config { }\nfunction testFib8() {\n    int result = fib(8);\n    test:assertEquals(result, 21, msg = \"fib(8) should return 21\");\n}\n\n@test:Config { }\nfunction testFib11() {\n    int result = fib(11);\n    test:assertEquals(result, 89, msg = \"fib(11) should return 89\");\n}\n\n@test:Config { }\nfunction testFib12() {\n    int result = fib(12);\n    test:assertEquals(result, 144, msg = \"fib(12) should return 144\");\n}"
  },
  {
    "id": "request-53",
    "prompt": "Write a function that takes a string containing only \"<\" and \">\" characters and returns true if every opening bracket \"<\" has a corresponding closing bracket \">\". The brackets must be properly nested and balanced.\n\n```ballerina\nfunction correct_bracketing(brackets: string) returns boolean {\n    // Your implementation here\n}\n```\n\nExamples:\n- correct_bracketing(\"<\") should return false\n- correct_bracketing(\"<>\") should return true  \n- correct_bracketing(\"<<><>>\") should return true\n- correct_bracketing(\"><<>\") should return false",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testCorrectBracketing1() {\n    test:assertEquals(correct_bracketing(\"<>\"), true, msg = \"Failed for '<>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing2() {\n    test:assertEquals(correct_bracketing(\"<<><>>\"), true, msg = \"Failed for '<<><>>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing3() {\n    test:assertEquals(correct_bracketing(\"<><><<><>><>\"), true, msg = \"Failed for '<><><<><>><>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing4() {\n    test:assertEquals(correct_bracketing(\"<><><<<><><>><>><<><><<>>>\"), true, msg = \"Failed for '<><><<<><><>><>><<><><<>>>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing5() {\n    test:assertEquals(correct_bracketing(\"<<<><>>>>\"), false, msg = \"Failed for '<<<><>>>>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing6() {\n    test:assertEquals(correct_bracketing(\"><<>\"), false, msg = \"Failed for '><<>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing7() {\n    test:assertEquals(correct_bracketing(\"<\"), false, msg = \"Failed for '<'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing8() {\n    test:assertEquals(correct_bracketing(\"<<<<\"), false, msg = \"Failed for '<<<<'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing9() {\n    test:assertEquals(correct_bracketing(\">\"), false, msg = \"Failed for '>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing10() {\n    test:assertEquals(correct_bracketing(\"<<>\"), false, msg = \"Failed for '<<>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing11() {\n    test:assertEquals(correct_bracketing(\"<><><<><>><>><<>\"), false, msg = \"Failed for '<><><<><>><>><<>'\");\n}\n\n@test:Config {}\nfunction testCorrectBracketing12() {\n    test:assertEquals(correct_bracketing(\"<><><<><>><>>><>\"), false, msg = \"Failed for '<><><<><>><>>><>'\");\n}"
  },
  {
    "id": "request-54",
    "prompt": "Write a function that returns true if array elements are monotonically increasing or decreasing (non-strictly), and false otherwise.\n\n```ballerina\nfunction monotonic(l int[]) returns boolean {\n    // Your implementation here\n}\n```\n\nExamples:\n- monotonic([1, 2, 4, 20]) should return true\n- monotonic([1, 20, 4, 10]) should return false  \n- monotonic([4, 1, 0, -10]) should return true",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMonotonic1() {\n    boolean result = monotonic([1, 2, 4, 10]);\n    test:assertTrue(result, msg = \"Expected true for [1, 2, 4, 10]\");\n}\n\n@test:Config { }\nfunction testMonotonic2() {\n    boolean result = monotonic([1, 2, 4, 20]);\n    test:assertTrue(result, msg = \"Expected true for [1, 2, 4, 20]\");\n}\n\n@test:Config { }\nfunction testMonotonic3() {\n    boolean result = monotonic([1, 20, 4, 10]);\n    test:assertFalse(result, msg = \"Expected false for [1, 20, 4, 10]\");\n}\n\n@test:Config { }\nfunction testMonotonic4() {\n    boolean result = monotonic([4, 1, 0, -10]);\n    test:assertTrue(result, msg = \"Expected true for [4, 1, 0, -10]\");\n}\n\n@test:Config { }\nfunction testMonotonic5() {\n    boolean result = monotonic([4, 1, 1, 0]);\n    test:assertTrue(result, msg = \"Expected true for [4, 1, 1, 0]\");\n}\n\n@test:Config { }\nfunction testMonotonic6() {\n    boolean result = monotonic([1, 2, 3, 2, 5, 60]);\n    test:assertFalse(result, msg = \"Expected false for [1, 2, 3, 2, 5, 60]\");\n}\n\n@test:Config { }\nfunction testMonotonic7() {\n    boolean result = monotonic([1, 2, 3, 4, 5, 60]);\n    test:assertTrue(result, msg = \"Expected true for [1, 2, 3, 4, 5, 60]\");\n}\n\n@test:Config { }\nfunction testMonotonic8() {\n    boolean result = monotonic([9, 9, 9, 9]);\n    test:assertTrue(result, msg = \"Expected true for [9, 9, 9, 9]\");\n}"
  },
  {
    "id": "request-55",
    "prompt": "Return sorted unique common elements for two arrays.\n\n```ballerina\nfunction common(l1 int[], l2 int[]) returns int[] {\n    // Your implementation here\n}\n```\n\nExamples:\n- common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) should return [1, 5, 653]\n- common([5, 3, 2, 8], [3, 2]) should return [2, 3]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCommon1() {\n    int[] result = common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]);\n    test:assertEquals(result, [1, 5, 653], msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testCommon2() {\n    int[] result = common([5, 3, 2, 8], [3, 2]);\n    test:assertEquals(result, [2, 3], msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testCommon3() {\n    int[] result = common([4, 3, 2, 8], [3, 2, 4]);\n    test:assertEquals(result, [2, 3, 4], msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testCommon4() {\n    int[] result = common([4, 3, 2, 8], []);\n    test:assertEquals(result, [], msg = \"Test case 4 failed\");\n}"
  },
  {
    "id": "request-56",
    "prompt": "// Find and return the largest prime factor of the given number n.\n// Assume n > 1 and n is not a prime number.\n// largest_prime_factor(13195) returns 29\n// largest_prime_factor(2048) returns 2\nfunction largest_prime_factor(n int) returns int {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testLargestPrimeFactor1() {\n    int result = largest_prime_factor(15);\n    test:assertEquals(result, 5, msg = \"Failed for input 15\");\n}\n\n@test:Config { }\nfunction testLargestPrimeFactor2() {\n    int result = largest_prime_factor(27);\n    test:assertEquals(result, 3, msg = \"Failed for input 27\");\n}\n\n@test:Config { }\nfunction testLargestPrimeFactor3() {\n    int result = largest_prime_factor(63);\n    test:assertEquals(result, 7, msg = \"Failed for input 63\");\n}\n\n@test:Config { }\nfunction testLargestPrimeFactor4() {\n    int result = largest_prime_factor(330);\n    test:assertEquals(result, 11, msg = \"Failed for input 330\");\n}\n\n@test:Config { }\nfunction testLargestPrimeFactor5() {\n    int result = largest_prime_factor(13195);\n    test:assertEquals(result, 29, msg = \"Failed for input 13195\");\n}"
  },
  {
    "id": "request-57",
    "prompt": "Write a function called `sum_to_n` that takes an integer `n` and returns the sum of all numbers from 1 to n (inclusive).\n\n```ballerina\nfunction sum_to_n(n int) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n// sum_to_n(30) returns 465\n// sum_to_n(100) returns 5050\n// sum_to_n(5) returns 15\n// sum_to_n(10) returns 55\n// sum_to_n(1) returns 1",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSumToN1() {\n    int result = sum_to_n(1);\n    test:assertEquals(result, 1, msg = \"sum_to_n(1) should return 1\");\n}\n\n@test:Config { }\nfunction testSumToN6() {\n    int result = sum_to_n(6);\n    test:assertEquals(result, 21, msg = \"sum_to_n(6) should return 21\");\n}\n\n@test:Config { }\nfunction testSumToN11() {\n    int result = sum_to_n(11);\n    test:assertEquals(result, 66, msg = \"sum_to_n(11) should return 66\");\n}\n\n@test:Config { }\nfunction testSumToN30() {\n    int result = sum_to_n(30);\n    test:assertEquals(result, 465, msg = \"sum_to_n(30) should return 465\");\n}\n\n@test:Config { }\nfunction testSumToN100() {\n    int result = sum_to_n(100);\n    test:assertEquals(result, 5050, msg = \"sum_to_n(100) should return 5050\");\n}"
  },
  {
    "id": "request-58",
    "prompt": "Write a function that takes a string containing only \"(\" and \")\" characters and returns true if every opening bracket has a corresponding closing bracket in the correct order, false otherwise.\n\nFunction signature:\n```ballerina\nfunction correct_bracketing(brackets string) returns boolean\n```\n\nExamples:\n- correct_bracketing(\"(\") should return false\n- correct_bracketing(\"()\") should return true  \n- correct_bracketing(\"(()())\") should return true\n- correct_bracketing(\")(()\") should return false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCorrectBracketing1() {\n    test:assertTrue(correct_bracketing(\"()\"), msg = \"Simple pair should be valid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing2() {\n    test:assertTrue(correct_bracketing(\"(()())\"), msg = \"Nested brackets should be valid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing3() {\n    test:assertTrue(correct_bracketing(\"()()(()())()\"), msg = \"Mixed brackets should be valid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing4() {\n    test:assertTrue(correct_bracketing(\"()()((()()())())(()()(()))\"), msg = \"Complex valid brackets\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing5() {\n    test:assertFalse(correct_bracketing(\"((()())))\"), msg = \"Unbalanced brackets should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing6() {\n    test:assertFalse(correct_bracketing(\")(()\"), msg = \"Starting with closing bracket should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing7() {\n    test:assertFalse(correct_bracketing(\"(\"), msg = \"Single opening bracket should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing8() {\n    test:assertFalse(correct_bracketing(\"((((\"), msg = \"Only opening brackets should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing9() {\n    test:assertFalse(correct_bracketing(\")\"), msg = \"Single closing bracket should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing10() {\n    test:assertFalse(correct_bracketing(\"(()\"), msg = \"Unmatched opening bracket should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing11() {\n    test:assertFalse(correct_bracketing(\"()()(()())())(()\"), msg = \"Extra closing bracket should be invalid\");\n}\n\n@test:Config { }\nfunction testCorrectBracketing12() {\n    test:assertFalse(correct_bracketing(\"()()(()())()))()\"), msg = \"Multiple extra closing brackets should be invalid\");\n}"
  },
  {
    "id": "request-59",
    "prompt": "Given an array of numbers representing coefficients of a polynomial where xs[0] + xs[1] * x + xs[2] * x^2 + ..., return the derivative of this polynomial in the same form.\n\nFor example:\n- derivative([3, 1, 2, 4, 5]) should return [1, 4, 12, 20]\n- derivative([1, 2, 3]) should return [2, 6]\n\nfunction derivative(xs: int[]) returns int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testDerivative1() {\n    int[] result = derivative([3, 1, 2, 4, 5]);\n    test:assertEquals(result, [1, 4, 12, 20], msg = \"Failed for [3, 1, 2, 4, 5]\");\n}\n\n@test:Config {}\nfunction testDerivative2() {\n    int[] result = derivative([1, 2, 3]);\n    test:assertEquals(result, [2, 6], msg = \"Failed for [1, 2, 3]\");\n}\n\n@test:Config {}\nfunction testDerivative3() {\n    int[] result = derivative([3, 2, 1]);\n    test:assertEquals(result, [2, 2], msg = \"Failed for [3, 2, 1]\");\n}\n\n@test:Config {}\nfunction testDerivative4() {\n    int[] result = derivative([3, 2, 1, 0, 4]);\n    test:assertEquals(result, [2, 2, 0, 16], msg = \"Failed for [3, 2, 1, 0, 4]\");\n}\n\n@test:Config {}\nfunction testDerivative5() {\n    int[] result = derivative([1]);\n    test:assertEquals(result, [], msg = \"Failed for [1]\");\n}"
  },
  {
    "id": "request-60",
    "prompt": "The FibFib number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:\n- fibfib(0) == 0\n- fibfib(1) == 0  \n- fibfib(2) == 1\n- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n > 2\n\nPlease write a function to efficiently compute the n-th element of the fibfib number sequence.\n\nExamples:\n- fibfib(1) should return 0\n- fibfib(5) should return 4\n- fibfib(8) should return 24\n\nfunction fibfib(n int) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFibFib2() {\n    int result = fibfib(2);\n    test:assertEquals(result, 1, msg = \"fibfib(2) should equal 1\");\n}\n\n@test:Config { }\nfunction testFibFib1() {\n    int result = fibfib(1);\n    test:assertEquals(result, 0, msg = \"fibfib(1) should equal 0\");\n}\n\n@test:Config { }\nfunction testFibFib5() {\n    int result = fibfib(5);\n    test:assertEquals(result, 4, msg = \"fibfib(5) should equal 4\");\n}\n\n@test:Config { }\nfunction testFibFib8() {\n    int result = fibfib(8);\n    test:assertEquals(result, 24, msg = \"fibfib(8) should equal 24\");\n}\n\n@test:Config { }\nfunction testFibFib10() {\n    int result = fibfib(10);\n    test:assertEquals(result, 81, msg = \"fibfib(10) should equal 81\");\n}\n\n@test:Config { }\nfunction testFibFib12() {\n    int result = fibfib(12);\n    test:assertEquals(result, 274, msg = \"fibfib(12) should equal 274\");\n}\n\n@test:Config { }\nfunction testFibFib14() {\n    int result = fibfib(14);\n    test:assertEquals(result, 927, msg = \"fibfib(14) should equal 927\");\n}"
  },
  {
    "id": "request-61",
    "prompt": "Write a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.\n\nExample:\n// vowels_count(\"abcde\") returns 2\n// vowels_count(\"ACEDY\") returns 3\n\nfunction vowels_count(s string) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testVowelsCount1() {\n    int result = vowels_count(\"abcde\");\n    test:assertEquals(result, 2, msg = \"Failed for 'abcde'\");\n}\n\n@test:Config { }\nfunction testVowelsCount2() {\n    int result = vowels_count(\"Alone\");\n    test:assertEquals(result, 3, msg = \"Failed for 'Alone'\");\n}\n\n@test:Config { }\nfunction testVowelsCount3() {\n    int result = vowels_count(\"key\");\n    test:assertEquals(result, 2, msg = \"Failed for 'key'\");\n}\n\n@test:Config { }\nfunction testVowelsCount4() {\n    int result = vowels_count(\"bye\");\n    test:assertEquals(result, 1, msg = \"Failed for 'bye'\");\n}\n\n@test:Config { }\nfunction testVowelsCount5() {\n    int result = vowels_count(\"keY\");\n    test:assertEquals(result, 2, msg = \"Failed for 'keY'\");\n}\n\n@test:Config { }\nfunction testVowelsCount6() {\n    int result = vowels_count(\"bYe\");\n    test:assertEquals(result, 1, msg = \"Failed for 'bYe'\");\n}\n\n@test:Config { }\nfunction testVowelsCount7() {\n    int result = vowels_count(\"ACEDY\");\n    test:assertEquals(result, 3, msg = \"Failed for 'ACEDY'\");\n}"
  },
  {
    "id": "request-62",
    "prompt": "// Circular shift the digits of the integer x, shift the digits right by shift\n// and return the result as a string.\n// If shift > number of digits, return digits reversed.\n// circular_shift(12, 1) should return \"21\"\n// circular_shift(12, 2) should return \"12\"\nfunction circular_shift(x int, shift int) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCircularShift1() {\n    string result = circular_shift(100, 2);\n    test:assertEquals(result, \"001\", msg = \"circular_shift(100, 2) should return '001'\");\n}\n\n@test:Config { }\nfunction testCircularShift2() {\n    string result = circular_shift(12, 2);\n    test:assertEquals(result, \"12\", msg = \"circular_shift(12, 2) should return '12'\");\n}\n\n@test:Config { }\nfunction testCircularShift3() {\n    string result = circular_shift(97, 8);\n    test:assertEquals(result, \"79\", msg = \"circular_shift(97, 8) should return '79'\");\n}\n\n@test:Config { }\nfunction testCircularShift4() {\n    string result = circular_shift(12, 1);\n    test:assertEquals(result, \"21\", msg = \"circular_shift(12, 1) should return '21'\");\n}\n\n@test:Config { }\nfunction testCircularShift5() {\n    string result = circular_shift(11, 101);\n    test:assertEquals(result, \"11\", msg = \"circular_shift(11, 101) should return '11'\");\n}"
  },
  {
    "id": "request-63",
    "prompt": "Write a function that takes a string as input and returns the sum of the upper characters only ASCII codes.\n\nExamples:\n- digitSum(\"\") should return 0\n- digitSum(\"abAB\") should return 131\n- digitSum(\"abcCd\") should return 67\n- digitSum(\"helloE\") should return 69\n- digitSum(\"woArBld\") should return 131\n- digitSum(\"aAaaaXa\") should return 153\n\nfunction digitSum(string s) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testDigitSumEmpty() {\n    int result = digitSum(\"\");\n    test:assertEquals(result, 0, msg = \"Empty string should return 0\");\n}\n\n@test:Config { }\nfunction testDigitSumAbAB() {\n    int result = digitSum(\"abAB\");\n    test:assertEquals(result, 131, msg = \"abAB should return 131\");\n}\n\n@test:Config { }\nfunction testDigitSumAbcCd() {\n    int result = digitSum(\"abcCd\");\n    test:assertEquals(result, 67, msg = \"abcCd should return 67\");\n}\n\n@test:Config { }\nfunction testDigitSumHelloE() {\n    int result = digitSum(\"helloE\");\n    test:assertEquals(result, 69, msg = \"helloE should return 69\");\n}\n\n@test:Config { }\nfunction testDigitSumWoArBld() {\n    int result = digitSum(\"woArBld\");\n    test:assertEquals(result, 131, msg = \"woArBld should return 131\");\n}\n\n@test:Config { }\nfunction testDigitSumAAaaaXa() {\n    int result = digitSum(\"aAaaaXa\");\n    test:assertEquals(result, 153, msg = \"aAaaaXa should return 153\");\n}\n\n@test:Config { }\nfunction testDigitSumHowAreYou() {\n    int result = digitSum(\" How are yOu?\");\n    test:assertEquals(result, 151, msg = \" How are yOu? should return 151\");\n}\n\n@test:Config { }\nfunction testDigitSumYouAreVerySmart() {\n    int result = digitSum(\"You arE Very Smart\");\n    test:assertEquals(result, 327, msg = \"You arE Very Smart should return 327\");\n}"
  },
  {
    "id": "request-64",
    "prompt": "// Given a string that represents the number of apples and oranges distributed in a basket, \n// and an integer representing the total number of fruits in the basket (which contains apples, oranges, and mangoes),\n// return the number of mango fruits in the basket.\n// \n// Examples:\n// fruit_distribution(\"5 apples and 6 oranges\", 19) // should return 8\n// fruit_distribution(\"0 apples and 1 oranges\", 3) // should return 2\n// fruit_distribution(\"2 apples and 3 oranges\", 100) // should return 95\n// fruit_distribution(\"100 apples and 1 oranges\", 120) // should return 19\n\nfunction fruit_distribution(s string, n int) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFruitDistribution1() {\n    int result = fruit_distribution(\"5 apples and 6 oranges\", 19);\n    test:assertEquals(result, 8, msg = \"Expected 8 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution2() {\n    int result = fruit_distribution(\"5 apples and 6 oranges\", 21);\n    test:assertEquals(result, 10, msg = \"Expected 10 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution3() {\n    int result = fruit_distribution(\"0 apples and 1 oranges\", 3);\n    test:assertEquals(result, 2, msg = \"Expected 2 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution4() {\n    int result = fruit_distribution(\"1 apples and 0 oranges\", 3);\n    test:assertEquals(result, 2, msg = \"Expected 2 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution5() {\n    int result = fruit_distribution(\"2 apples and 3 oranges\", 100);\n    test:assertEquals(result, 95, msg = \"Expected 95 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution6() {\n    int result = fruit_distribution(\"2 apples and 3 oranges\", 5);\n    test:assertEquals(result, 0, msg = \"Expected 0 mangoes\");\n}\n\n@test:Config { }\nfunction testFruitDistribution7() {\n    int result = fruit_distribution(\"1 apples and 100 oranges\", 120);\n    test:assertEquals(result, 19, msg = \"Expected 19 mangoes\");\n}"
  },
  {
    "id": "request-65",
    "prompt": "Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found, return the node that has the smallest index. The plucked node should be returned in an array [smallest_value, its_index]. If there are no even values or the given array is empty, return an empty array.\n\nWrite a function with the signature:\n```ballerina\nfunction pluck(arr int[]) returns int[]\n```\n\nExample calls:\n```ballerina\npluck([4, 2, 3]) // [2, 1] - 2 has the smallest even value at index 1\npluck([1, 2, 3]) // [2, 1] - 2 has the smallest even value at index 1  \npluck([]) // [] - empty array\npluck([5, 0, 3, 0, 4, 2]) // [0, 1] - 0 is smallest, choose first occurrence at index 1\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testPluck1() {\n    int[] result = pluck([4, 2, 3]);\n    test:assertEquals(result, [2, 1], msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testPluck2() {\n    int[] result = pluck([1, 2, 3]);\n    test:assertEquals(result, [2, 1], msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testPluck3() {\n    int[] result = pluck([]);\n    test:assertEquals(result, [], msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testPluck4() {\n    int[] result = pluck([5, 0, 3, 0, 4, 2]);\n    test:assertEquals(result, [0, 1], msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testPluck5() {\n    int[] result = pluck([1, 2, 3, 0, 5, 3]);\n    test:assertEquals(result, [0, 3], msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testPluck6() {\n    int[] result = pluck([5, 4, 8, 4, 8]);\n    test:assertEquals(result, [4, 1], msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testPluck7() {\n    int[] result = pluck([7, 6, 7, 1]);\n    test:assertEquals(result, [6, 1], msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testPluck8() {\n    int[] result = pluck([7, 9, 7, 1]);\n    test:assertEquals(result, [], msg = \"Test case 8 failed\");\n}"
  },
  {
    "id": "request-66",
    "prompt": "You are given a non-empty array of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the array. If no such value exists, return -1.\n\nWrite a function with the following signature:\n```ballerina\nfunction search(lst int[]) returns int\n```\n\nExamples:\n- search([4, 1, 2, 2, 3, 1]) should return 2\n- search([1, 2, 2, 3, 3, 3, 4, 4, 4]) should return 3  \n- search([5, 5, 4, 4, 4]) should return -1",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testSearch() {\n    test:assertEquals(search([5, 5, 5, 5, 1]), 1);\n    test:assertEquals(search([4, 1, 4, 1, 4, 4]), 4);\n    test:assertEquals(search([3, 3]), -1);\n    test:assertEquals(search([8, 8, 8, 8, 8, 8, 8, 8]), 8);\n    test:assertEquals(search([2, 3, 3, 2, 2]), 2);\n    test:assertEquals(search([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]), 1);\n    test:assertEquals(search([3, 2, 8, 2]), 2);\n    test:assertEquals(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]), 1);\n    test:assertEquals(search([8, 8, 3, 6, 5, 6, 4]), -1);\n    test:assertEquals(search([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]), 1);\n    test:assertEquals(search([1, 9, 10, 1, 3]), 1);\n    test:assertEquals(search([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]), 5);\n    test:assertEquals(search([1]), 1);\n    test:assertEquals(search([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]), 4);\n    test:assertEquals(search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]), 2);\n    test:assertEquals(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]), 1);\n    test:assertEquals(search([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]), 4);\n    test:assertEquals(search([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]), 4);\n    test:assertEquals(search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]), 2);\n    test:assertEquals(search([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]), -1);\n    test:assertEquals(search([10]), -1);\n    test:assertEquals(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]), 2);\n    test:assertEquals(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]), 1);\n    test:assertEquals(search([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]), 1);\n    test:assertEquals(search([3, 10, 10, 9, 2]), -1);\n}"
  },
  {
    "id": "request-67",
    "prompt": "Given an array of integers, return the array in a strange order. Strange sorting works by starting with the minimum value, then the maximum of the remaining integers, then the minimum again, and so on, alternating between min and max until all elements are processed.\n\nWrite a function that takes an array of integers and returns a new array sorted in this strange order.\n\nExamples:\n// strange_sort_list([1, 2, 3, 4]) should return [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) should return [5, 5, 5, 5]  \n// strange_sort_list([]) should return []\n\nfunction strange_sort_list(lst: int[]) returns int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStrangeSortBasic() {\n    int[] result = strange_sort_list([1, 2, 3, 4]);\n    int[] expected = [1, 4, 2, 3];\n    test:assertEquals(result, expected, msg = \"Basic strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortFiveElements() {\n    int[] result = strange_sort_list([5, 6, 7, 8, 9]);\n    int[] expected = [5, 9, 6, 8, 7];\n    test:assertEquals(result, expected, msg = \"Five elements strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortOddLength() {\n    int[] result = strange_sort_list([1, 2, 3, 4, 5]);\n    int[] expected = [1, 5, 2, 4, 3];\n    test:assertEquals(result, expected, msg = \"Odd length strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortSixElements() {\n    int[] result = strange_sort_list([5, 6, 7, 8, 9, 1]);\n    int[] expected = [1, 9, 5, 8, 6, 7];\n    test:assertEquals(result, expected, msg = \"Six elements strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortAllSame() {\n    int[] result = strange_sort_list([5, 5, 5, 5]);\n    int[] expected = [5, 5, 5, 5];\n    test:assertEquals(result, expected, msg = \"All same elements strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortEmpty() {\n    int[] result = strange_sort_list([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortEightElements() {\n    int[] result = strange_sort_list([1, 2, 3, 4, 5, 6, 7, 8]);\n    int[] expected = [1, 8, 2, 7, 3, 6, 4, 5];\n    test:assertEquals(result, expected, msg = \"Eight elements strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortWithNegatives() {\n    int[] result = strange_sort_list([0, 2, 2, 2, 5, 5, -5, -5]);\n    int[] expected = [-5, 5, -5, 5, 0, 2, 2, 2];\n    test:assertEquals(result, expected, msg = \"Array with negatives strange sort failed\");\n}\n\n@test:Config { }\nfunction testStrangeSortSingleElement() {\n    int[] result = strange_sort_list([111111]);\n    int[] expected = [111111];\n    test:assertEquals(result, expected, msg = \"Single element strange sort failed\");\n}"
  },
  {
    "id": "request-68",
    "prompt": "// Given the lengths of the three sides of a triangle, return the area of\n// the triangle rounded to 2 decimal places if the three sides form a valid triangle. \n// Otherwise return -1.\n// Three sides make a valid triangle when the sum of any two sides is greater \n// than the third side.\n// Example:\n// triangle_area(3, 4, 5) should return 6.0\n// triangle_area(1, 2, 10) should return -1\n\nfunction triangle_area(a: float, b: float, c: float) returns float {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTriangleArea1() {\n    float result = triangle_area(3, 4, 5);\n    test:assertEquals(result, 6.0, msg = \"Triangle area calculation failed\");\n}\n\n@test:Config { }\nfunction testTriangleArea2() {\n    float result = triangle_area(1, 2, 10);\n    test:assertEquals(result, -1.0, msg = \"Invalid triangle should return -1\");\n}\n\n@test:Config { }\nfunction testTriangleArea3() {\n    float result = triangle_area(4, 8, 5);\n    test:assertEquals(result, 8.18, msg = \"Triangle area calculation failed\");\n}\n\n@test:Config { }\nfunction testTriangleArea4() {\n    float result = triangle_area(2, 2, 2);\n    test:assertEquals(result, 1.73, msg = \"Equilateral triangle area calculation failed\");\n}\n\n@test:Config { }\nfunction testTriangleArea5() {\n    float result = triangle_area(1, 2, 3);\n    test:assertEquals(result, -1.0, msg = \"Invalid triangle should return -1\");\n}\n\n@test:Config { }\nfunction testTriangleArea6() {\n    float result = triangle_area(10, 5, 7);\n    test:assertEquals(result, 16.25, msg = \"Triangle area calculation failed\");\n}\n\n@test:Config { }\nfunction testTriangleArea7() {\n    float result = triangle_area(2, 6, 3);\n    test:assertEquals(result, -1.0, msg = \"Invalid triangle should return -1\");\n}\n\n@test:Config { }\nfunction testTriangleArea8() {\n    float result = triangle_area(1, 1, 1);\n    test:assertEquals(result, 0.43, msg = \"Unit equilateral triangle area calculation failed\");\n}\n\n@test:Config { }\nfunction testTriangleArea9() {\n    float result = triangle_area(2, 2, 10);\n    test:assertEquals(result, -1.0, msg = \"Invalid triangle should return -1\");\n}"
  },
  {
    "id": "request-69",
    "prompt": "Write a function that returns true if the object q will fly, and false otherwise.\nThe object q will fly if it's balanced (it is a palindromic array) and the sum of its elements is less than or equal the maximum possible weight w.\n\nExamples:\nwill_it_fly([1, 2], 5) // false - 1+2 is less than the maximum possible weight, but it's unbalanced\nwill_it_fly([3, 2, 3], 1) // false - it's balanced, but 3+2+3 is more than the maximum possible weight\nwill_it_fly([3, 2, 3], 9) // true - 3+2+3 is less than the maximum possible weight, and it's balanced\nwill_it_fly([3], 5) // true - 3 is less than the maximum possible weight, and it's balanced\n\nfunction will_it_fly(q: int[], w: int) returns boolean {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testWillItFly1() {\n    boolean result = will_it_fly([3, 2, 3], 9);\n    test:assertTrue(result, msg = \"Expected true for balanced array with sum <= weight\");\n}\n\n@test:Config {}\nfunction testWillItFly2() {\n    boolean result = will_it_fly([1, 2], 5);\n    test:assertFalse(result, msg = \"Expected false for unbalanced array\");\n}\n\n@test:Config {}\nfunction testWillItFly3() {\n    boolean result = will_it_fly([3], 5);\n    test:assertTrue(result, msg = \"Expected true for single element array with sum <= weight\");\n}\n\n@test:Config {}\nfunction testWillItFly4() {\n    boolean result = will_it_fly([3, 2, 3], 1);\n    test:assertFalse(result, msg = \"Expected false for balanced array with sum > weight\");\n}\n\n@test:Config {}\nfunction testWillItFly5() {\n    boolean result = will_it_fly([1, 2, 3], 6);\n    test:assertFalse(result, msg = \"Expected false for unbalanced array\");\n}\n\n@test:Config {}\nfunction testWillItFly6() {\n    boolean result = will_it_fly([5], 5);\n    test:assertTrue(result, msg = \"Expected true for single element array with sum = weight\");\n}"
  },
  {
    "id": "request-70",
    "prompt": "Given an array of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array reads the same backwards and forwards. In one change, you can change one element to any other element.\n\nFor example:\n- smallest_change([1, 2, 3, 5, 4, 7, 9, 6]) should return 4\n- smallest_change([1, 2, 3, 4, 3, 2, 2]) should return 1  \n- smallest_change([1, 2, 3, 2, 1]) should return 0\n\nfunction smallest_change(arr int[]) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSmallestChange1() {\n    int result = smallest_change([1, 2, 3, 5, 4, 7, 9, 6]);\n    test:assertEquals(result, 4, msg = \"Failed for [1, 2, 3, 5, 4, 7, 9, 6]\");\n}\n\n@test:Config { }\nfunction testSmallestChange2() {\n    int result = smallest_change([1, 2, 3, 4, 3, 2, 2]);\n    test:assertEquals(result, 1, msg = \"Failed for [1, 2, 3, 4, 3, 2, 2]\");\n}\n\n@test:Config { }\nfunction testSmallestChange3() {\n    int result = smallest_change([1, 4, 2]);\n    test:assertEquals(result, 1, msg = \"Failed for [1, 4, 2]\");\n}\n\n@test:Config { }\nfunction testSmallestChange4() {\n    int result = smallest_change([1, 4, 4, 2]);\n    test:assertEquals(result, 1, msg = \"Failed for [1, 4, 4, 2]\");\n}\n\n@test:Config { }\nfunction testSmallestChange5() {\n    int result = smallest_change([1, 2, 3, 2, 1]);\n    test:assertEquals(result, 0, msg = \"Failed for [1, 2, 3, 2, 1]\");\n}\n\n@test:Config { }\nfunction testSmallestChange6() {\n    int result = smallest_change([3, 1, 1, 3]);\n    test:assertEquals(result, 0, msg = \"Failed for [3, 1, 1, 3]\");\n}\n\n@test:Config { }\nfunction testSmallestChange7() {\n    int result = smallest_change([1]);\n    test:assertEquals(result, 0, msg = \"Failed for [1]\");\n}\n\n@test:Config { }\nfunction testSmallestChange8() {\n    int result = smallest_change([0, 1]);\n    test:assertEquals(result, 1, msg = \"Failed for [0, 1]\");\n}"
  },
  {
    "id": "request-71",
    "prompt": "Write a function that accepts two arrays of strings and returns the array that has the total number of characters in all strings of the array less than the other array. If the two arrays have the same number of characters, return the first array.\n\n```ballerina\nfunction total_match(lst1 string[], lst2 string[]) returns string[] {\n    // Your implementation here\n}\n```\n\nExamples:\n- `total_match([], [])` should return `[]`\n- `total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"])` should return `[\"hI\", \"Hi\"]`\n- `total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"])` should return `[\"hi\", \"admin\"]`\n- `total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"])` should return `[\"hI\", \"hi\", \"hi\"]`\n- `total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"])` should return `[\"4\"]`",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTotalMatchEmpty() {\n    string[] result = total_match([], []);\n    test:assertEquals(result, [], msg = \"Empty arrays test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchEqual() {\n    string[] result = total_match([\"hi\", \"admin\"], [\"hi\", \"hi\"]);\n    test:assertEquals(result, [\"hi\", \"hi\"], msg = \"Equal length test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchFirstShorter() {\n    string[] result = total_match([\"hi\", \"admin\"], [\"hi\", \"hi\", \"admin\", \"project\"]);\n    test:assertEquals(result, [\"hi\", \"admin\"], msg = \"First array shorter test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchSingleVsMultiple() {\n    string[] result = total_match([\"4\"], [\"1\", \"2\", \"3\", \"4\", \"5\"]);\n    test:assertEquals(result, [\"4\"], msg = \"Single vs multiple test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchCase() {\n    string[] result = total_match([\"hi\", \"admin\"], [\"hI\", \"Hi\"]);\n    test:assertEquals(result, [\"hI\", \"Hi\"], msg = \"Case test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchSecondShorter() {\n    string[] result = total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hi\"]);\n    test:assertEquals(result, [\"hI\", \"hi\", \"hi\"], msg = \"Second array shorter test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchFirstShorterAgain() {\n    string[] result = total_match([\"hi\", \"admin\"], [\"hI\", \"hi\", \"hii\"]);\n    test:assertEquals(result, [\"hi\", \"admin\"], msg = \"First array shorter again test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchEmptyFirst() {\n    string[] result = total_match([], [\"this\"]);\n    test:assertEquals(result, [], msg = \"Empty first array test failed\");\n}\n\n@test:Config { }\nfunction testTotalMatchEmptySecond() {\n    string[] result = total_match([\"this\"], []);\n    test:assertEquals(result, [], msg = \"Empty second array test failed\");\n}"
  },
  {
    "id": "request-72",
    "prompt": "Write a function that returns true if the given number is the multiplication of exactly 3 prime numbers and false otherwise. The input number is guaranteed to be less than 100.\n\nFor example:\n- is_multiply_prime(30) should return true because 30 = 2 * 3 * 5\n- is_multiply_prime(8) should return true because 8 = 2 * 2 * 2\n\n```ballerina\nfunction is_multiply_prime(a int) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected function calls:\n// is_multiply_prime(30) → true\n// is_multiply_prime(8) → true  \n// is_multiply_prime(5) → false\n// is_multiply_prime(10) → false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsMultiplyPrime() {\n    test:assertFalse(is_multiply_prime(5), msg = \"5 should return false\");\n    test:assertTrue(is_multiply_prime(30), msg = \"30 should return true\");\n    test:assertTrue(is_multiply_prime(8), msg = \"8 should return true\");\n    test:assertFalse(is_multiply_prime(10), msg = \"10 should return false\");\n    test:assertTrue(is_multiply_prime(125), msg = \"125 should return true\");\n    test:assertTrue(is_multiply_prime(105), msg = \"105 should return true\");\n    test:assertFalse(is_multiply_prime(126), msg = \"126 should return false\");\n    test:assertFalse(is_multiply_prime(729), msg = \"729 should return false\");\n    test:assertFalse(is_multiply_prime(891), msg = \"891 should return false\");\n    test:assertTrue(is_multiply_prime(1001), msg = \"1001 should return true\");\n}"
  },
  {
    "id": "request-73",
    "prompt": "Write a function that returns true if a number x is a simple power of n and false in other cases.\nx is a simple power of n if n raised to some integer power equals x.\n\nFor example:\n// is_simple_power(1, 4) returns true\n// is_simple_power(2, 2) returns true  \n// is_simple_power(8, 2) returns true\n// is_simple_power(3, 2) returns false\n// is_simple_power(3, 1) returns false\n// is_simple_power(5, 3) returns false\n\nfunction is_simple_power(int x, int n) returns boolean {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSimplePower1() {\n    test:assertEquals(is_simple_power(16, 2), true, msg = \"16 should be a simple power of 2\");\n}\n\n@test:Config { }\nfunction testSimplePower2() {\n    test:assertEquals(is_simple_power(143214, 16), false, msg = \"143214 should not be a simple power of 16\");\n}\n\n@test:Config { }\nfunction testSimplePower3() {\n    test:assertEquals(is_simple_power(4, 2), true, msg = \"4 should be a simple power of 2\");\n}\n\n@test:Config { }\nfunction testSimplePower4() {\n    test:assertEquals(is_simple_power(9, 3), true, msg = \"9 should be a simple power of 3\");\n}\n\n@test:Config { }\nfunction testSimplePower5() {\n    test:assertEquals(is_simple_power(16, 4), true, msg = \"16 should be a simple power of 4\");\n}\n\n@test:Config { }\nfunction testSimplePower6() {\n    test:assertEquals(is_simple_power(24, 2), false, msg = \"24 should not be a simple power of 2\");\n}\n\n@test:Config { }\nfunction testSimplePower7() {\n    test:assertEquals(is_simple_power(128, 4), false, msg = \"128 should not be a simple power of 4\");\n}\n\n@test:Config { }\nfunction testSimplePower8() {\n    test:assertEquals(is_simple_power(12, 6), false, msg = \"12 should not be a simple power of 6\");\n}\n\n@test:Config { }\nfunction testSimplePower9() {\n    test:assertEquals(is_simple_power(1, 1), true, msg = \"1 should be a simple power of 1\");\n}\n\n@test:Config { }\nfunction testSimplePower10() {\n    test:assertEquals(is_simple_power(1, 12), true, msg = \"1 should be a simple power of 12\");\n}"
  },
  {
    "id": "request-74",
    "prompt": "Write a function that takes an integer a and returns true if this integer is a cube of some integer number.\nNote: you may assume the input is always valid.\n\nExamples:\n// iscube(1) returns true\n// iscube(2) returns false  \n// iscube(-1) returns true\n// iscube(64) returns true\n// iscube(0) returns true\n// iscube(180) returns false\n\nfunction iscube(int a) returns boolean {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIscube() {\n    test:assertEquals(iscube(1), true, msg = \"iscube(1) should return true\");\n    test:assertEquals(iscube(2), false, msg = \"iscube(2) should return false\");\n    test:assertEquals(iscube(-1), true, msg = \"iscube(-1) should return true\");\n    test:assertEquals(iscube(64), true, msg = \"iscube(64) should return true\");\n    test:assertEquals(iscube(180), false, msg = \"iscube(180) should return false\");\n    test:assertEquals(iscube(1000), true, msg = \"iscube(1000) should return true\");\n    test:assertEquals(iscube(0), true, msg = \"iscube(0) should return true\");\n    test:assertEquals(iscube(1729), false, msg = \"iscube(1729) should return false\");\n}"
  },
  {
    "id": "request-75",
    "prompt": "Write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes. Prime numbers are natural numbers greater than 1 that are not a product of two smaller natural numbers.\n\nHexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\nPrime numbers are 2, 3, 5, 7, 11, 13, 17,...\n\nSo you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13).\n\nNote: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase.\n\nExamples:\nhex_key(\"AB\") // 1\nhex_key(\"1077E\") // 2\nhex_key(\"ABED1A33\") // 4\nhex_key(\"123456789ABCDEF0\") // 6\nhex_key(\"2020\") // 2\n\nfunction hex_key(num string) returns int {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testHexKey1() {\n    int result = hex_key(\"AB\");\n    test:assertEquals(result, 1, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testHexKey2() {\n    int result = hex_key(\"1077E\");\n    test:assertEquals(result, 2, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testHexKey3() {\n    int result = hex_key(\"ABED1A33\");\n    test:assertEquals(result, 4, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testHexKey4() {\n    int result = hex_key(\"2020\");\n    test:assertEquals(result, 2, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testHexKey5() {\n    int result = hex_key(\"123456789ABCDEF0\");\n    test:assertEquals(result, 6, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testHexKey6() {\n    int result = hex_key(\"112233445566778899AABBCCDDEEFF00\");\n    test:assertEquals(result, 12, msg = \"Test case 6 failed\");\n}"
  },
  {
    "id": "request-76",
    "prompt": "Write a function that converts a decimal number to binary format. The function should return a string where each character represents a binary digit ('0' or '1'). The binary string should have 'db' at the beginning and 'db' at the end for formatting purposes.\n\n```ballerina\nfunction decimal_to_binary(decimal int) returns string {\n    // Your implementation here\n}\n```\n\nExamples:\n- decimal_to_binary(15) should return \"db1111db\"\n- decimal_to_binary(32) should return \"db100000db\"\n- decimal_to_binary(0) should return \"db0db\"",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testDecimalToBinary1() {\n    string result = decimal_to_binary(0);\n    test:assertEquals(result, \"db0db\", msg = \"Failed for decimal 0\");\n}\n\n@test:Config { }\nfunction testDecimalToBinary2() {\n    string result = decimal_to_binary(32);\n    test:assertEquals(result, \"db100000db\", msg = \"Failed for decimal 32\");\n}\n\n@test:Config { }\nfunction testDecimalToBinary3() {\n    string result = decimal_to_binary(103);\n    test:assertEquals(result, \"db1100111db\", msg = \"Failed for decimal 103\");\n}\n\n@test:Config { }\nfunction testDecimalToBinary4() {\n    string result = decimal_to_binary(15);\n    test:assertEquals(result, \"db1111db\", msg = \"Failed for decimal 15\");\n}"
  },
  {
    "id": "request-77",
    "prompt": "You are given a string s. Your task is to check if the string is happy or not.\n\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct.\n\nFor example:\n// is_happy(\"a\") should return false\n// is_happy(\"aa\") should return false  \n// is_happy(\"abcd\") should return true\n// is_happy(\"aabb\") should return false\n// is_happy(\"adb\") should return true\n// is_happy(\"xyy\") should return false\n\nfunction is_happy(s string) returns boolean {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsHappy1() {\n    test:assertEquals(is_happy(\"a\"), false, msg = \"Single character should return false\");\n}\n\n@test:Config { }\nfunction testIsHappy2() {\n    test:assertEquals(is_happy(\"aa\"), false, msg = \"Two characters should return false\");\n}\n\n@test:Config { }\nfunction testIsHappy3() {\n    test:assertEquals(is_happy(\"abcd\"), true, msg = \"String with distinct consecutive chars should return true\");\n}\n\n@test:Config { }\nfunction testIsHappy4() {\n    test:assertEquals(is_happy(\"aabb\"), false, msg = \"String with repeated consecutive chars should return false\");\n}\n\n@test:Config { }\nfunction testIsHappy5() {\n    test:assertEquals(is_happy(\"adb\"), true, msg = \"Three distinct chars should return true\");\n}\n\n@test:Config { }\nfunction testIsHappy6() {\n    test:assertEquals(is_happy(\"xyy\"), false, msg = \"String with repeated chars should return false\");\n}\n\n@test:Config { }\nfunction testIsHappy7() {\n    test:assertEquals(is_happy(\"iopaxpoi\"), true, msg = \"Longer string with distinct consecutive chars should return true\");\n}\n\n@test:Config { }\nfunction testIsHappy8() {\n    test:assertEquals(is_happy(\"iopaxioi\"), false, msg = \"Longer string with repeated consecutive chars should return false\");\n}"
  },
  {
    "id": "request-78",
    "prompt": "Write a function that converts an array of GPAs (Grade Point Averages) to letter grades using the following grading scale:\n\n- GPA 4.0 = A+\n- GPA > 3.7 = A \n- GPA > 3.3 = A- \n- GPA > 3.0 = B+\n- GPA > 2.7 = B \n- GPA > 2.3 = B-\n- GPA > 2.0 = C+\n- GPA > 1.7 = C\n- GPA > 1.3 = C-\n- GPA > 1.0 = D+ \n- GPA > 0.7 = D \n- GPA > 0.0 = D-\n- GPA 0.0 = E\n\nFunction signature:\n```ballerina\nfunction numerical_letter_grade(grades: float[]) returns string[]\n```\n\nExample:\n```ballerina\nnumerical_letter_grade([4.0, 3.0, 1.7, 2.0, 3.5]) // returns [\"A+\", \"B+\", \"C\", \"C+\", \"A-\"]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testNumericalLetterGrade1() {\n    string[] result = numerical_letter_grade([4.0, 3.0, 1.7, 2.0, 3.5]);\n    string[] expected = [\"A+\", \"B+\", \"C\", \"C+\", \"A-\"];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testNumericalLetterGrade2() {\n    string[] result = numerical_letter_grade([1.2]);\n    string[] expected = [\"D+\"];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testNumericalLetterGrade3() {\n    string[] result = numerical_letter_grade([0.5]);\n    string[] expected = [\"D-\"];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testNumericalLetterGrade4() {\n    string[] result = numerical_letter_grade([0.0]);\n    string[] expected = [\"E\"];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testNumericalLetterGrade5() {\n    string[] result = numerical_letter_grade([1.0, 0.3, 1.5, 2.8, 3.3]);\n    string[] expected = [\"D\", \"D-\", \"C-\", \"B\", \"B+\"];\n    test:assertEquals(result, expected, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testNumericalLetterGrade6() {\n    string[] result = numerical_letter_grade([0.0, 0.7]);\n    string[] expected = [\"E\", \"D-\"];\n    test:assertEquals(result, expected, msg = \"Test case 6 failed\");\n}"
  },
  {
    "id": "request-79",
    "prompt": "Write a function that takes a string and returns true if the string length is a prime number or false otherwise.\n\nExamples:\n// prime_length(\"Hello\") → true (length 5 is prime)\n// prime_length(\"abcdcba\") → true (length 7 is prime) \n// prime_length(\"kittens\") → true (length 7 is prime)\n// prime_length(\"orange\") → false (length 6 is not prime)\n\nfunction prime_length(string str) returns boolean {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testPrimeLengthHello() {\n    test:assertTrue(prime_length(\"Hello\"), msg = \"Failed for 'Hello'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthAbcdcba() {\n    test:assertTrue(prime_length(\"abcdcba\"), msg = \"Failed for 'abcdcba'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthKittens() {\n    test:assertTrue(prime_length(\"kittens\"), msg = \"Failed for 'kittens'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthOrange() {\n    test:assertFalse(prime_length(\"orange\"), msg = \"Failed for 'orange'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthWow() {\n    test:assertTrue(prime_length(\"wow\"), msg = \"Failed for 'wow'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthWorld() {\n    test:assertTrue(prime_length(\"world\"), msg = \"Failed for 'world'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthMadaM() {\n    test:assertTrue(prime_length(\"MadaM\"), msg = \"Failed for 'MadaM'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthWowCapital() {\n    test:assertTrue(prime_length(\"Wow\"), msg = \"Failed for 'Wow'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthEmpty() {\n    test:assertFalse(prime_length(\"\"), msg = \"Failed for empty string\");\n}\n\n@test:Config { }\nfunction testPrimeLengthHI() {\n    test:assertTrue(prime_length(\"HI\"), msg = \"Failed for 'HI'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthGo() {\n    test:assertTrue(prime_length(\"go\"), msg = \"Failed for 'go'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthGogo() {\n    test:assertFalse(prime_length(\"gogo\"), msg = \"Failed for 'gogo'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthLongA() {\n    test:assertFalse(prime_length(\"aaaaaaaaaaaaaaa\"), msg = \"Failed for long 'a' string\");\n}\n\n@test:Config { }\nfunction testPrimeLengthMadam() {\n    test:assertTrue(prime_length(\"Madam\"), msg = \"Failed for 'Madam'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthM() {\n    test:assertFalse(prime_length(\"M\"), msg = \"Failed for 'M'\");\n}\n\n@test:Config { }\nfunction testPrimeLengthZero() {\n    test:assertFalse(prime_length(\"0\"), msg = \"Failed for '0'\");\n}"
  },
  {
    "id": "request-80",
    "prompt": "Given a positive integer n, return the count of n-digit positive integers that start or end with 1.\n\nWrite a function with the signature:\n```ballerina\nfunction starts_one_ends(int n) returns int\n```\n\nExamples:\n- starts_one_ends(1) should return 1 (only \"1\")\n- starts_one_ends(2) should return 18 (10-19 start with 1, plus 21,31,41,51,61,71,81,91 end with 1)\n- starts_one_ends(3) should return 180\n- starts_one_ends(4) should return 1800\n- starts_one_ends(5) should return 18000",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStartsOneEnds() {\n    test:assertEquals(starts_one_ends(1), 1, msg = \"Test case 1 failed\");\n    test:assertEquals(starts_one_ends(2), 18, msg = \"Test case 2 failed\");\n    test:assertEquals(starts_one_ends(3), 180, msg = \"Test case 3 failed\");\n    test:assertEquals(starts_one_ends(4), 1800, msg = \"Test case 4 failed\");\n    test:assertEquals(starts_one_ends(5), 18000, msg = \"Test case 5 failed\");\n}"
  },
  {
    "id": "request-81",
    "prompt": "Given a positive integer N, return the total sum of its digits in binary.\n\nWrite a function that takes a positive integer N, calculates the sum of all its digits, and returns the binary representation of that sum as a string.\n\n```ballerina\nfunction solve(N int) returns string {\n    // Your implementation here\n}\n```\n\nExamples:\n- solve(1000) should return \"1\" (digits: 1+0+0+0 = 1, binary of 1 is \"1\")\n- solve(150) should return \"110\" (digits: 1+5+0 = 6, binary of 6 is \"110\") \n- solve(147) should return \"1100\" (digits: 1+4+7 = 12, binary of 12 is \"1100\")\n\nConstraints: 0 ≤ N ≤ 10000",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSolve1000() {\n    test:assertEquals(solve(1000), \"1\", msg = \"Failed for N=1000\");\n}\n\n@test:Config { }\nfunction testSolve150() {\n    test:assertEquals(solve(150), \"110\", msg = \"Failed for N=150\");\n}\n\n@test:Config { }\nfunction testSolve147() {\n    test:assertEquals(solve(147), \"1100\", msg = \"Failed for N=147\");\n}\n\n@test:Config { }\nfunction testSolve333() {\n    test:assertEquals(solve(333), \"1001\", msg = \"Failed for N=333\");\n}\n\n@test:Config { }\nfunction testSolve963() {\n    test:assertEquals(solve(963), \"10010\", msg = \"Failed for N=963\");\n}"
  },
  {
    "id": "request-82",
    "prompt": "Given a non-empty array of integers, add up all the even elements that are positioned at odd indices (1, 3, 5, etc.).\n\nWrite a function `add` that takes an array of integers and returns the sum of even numbers at odd positions.\n\nExamples:\n- add([4, 2, 6, 7]) returns 2 (only element at index 1 is even)\n- add([4, 88]) returns 88 (element at index 1 is even)\n- add([4, 5, 6, 7, 2, 122]) returns 122 (element at index 5 is even)\n\nfunction add(lst: int[]) returns int",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAdd1() {\n    int result = add([4, 88]);\n    test:assertEquals(result, 88, msg = \"Failed for [4, 88]\");\n}\n\n@test:Config { }\nfunction testAdd2() {\n    int result = add([4, 5, 6, 7, 2, 122]);\n    test:assertEquals(result, 122, msg = \"Failed for [4, 5, 6, 7, 2, 122]\");\n}\n\n@test:Config { }\nfunction testAdd3() {\n    int result = add([4, 0, 6, 7]);\n    test:assertEquals(result, 0, msg = \"Failed for [4, 0, 6, 7]\");\n}\n\n@test:Config { }\nfunction testAdd4() {\n    int result = add([4, 4, 6, 8]);\n    test:assertEquals(result, 12, msg = \"Failed for [4, 4, 6, 8]\");\n}"
  },
  {
    "id": "request-83",
    "prompt": "Write a function that takes a string and returns an ordered version of it. The ordered version of a string is a string where all words (separated by space) are replaced by a new word where all the characters are arranged in ascending order based on ASCII value.\n\nNote: You should keep the order of words and blank spaces in the sentence.\n\nFor example:\n// anti_shuffle(\"Hi\") should return \"Hi\"\n// anti_shuffle(\"hello\") should return \"ehllo\"  \n// anti_shuffle(\"Hello World!!!\") should return \"Hello !!!Wdlor\"\n\nfunction anti_shuffle(s string) returns string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAntiShuffleHi() {\n    test:assertEquals(anti_shuffle(\"Hi\"), \"Hi\", msg = \"Failed for 'Hi'\");\n}\n\n@test:Config { }\nfunction testAntiShuffleHello() {\n    test:assertEquals(anti_shuffle(\"hello\"), \"ehllo\", msg = \"Failed for 'hello'\");\n}\n\n@test:Config { }\nfunction testAntiShuffleNumber() {\n    test:assertEquals(anti_shuffle(\"number\"), \"bemnru\", msg = \"Failed for 'number'\");\n}\n\n@test:Config { }\nfunction testAntiShuffleAbcd() {\n    test:assertEquals(anti_shuffle(\"abcd\"), \"abcd\", msg = \"Failed for 'abcd'\");\n}\n\n@test:Config { }\nfunction testAntiShuffleHelloWorld() {\n    test:assertEquals(anti_shuffle(\"Hello World!!!\"), \"Hello !!!Wdlor\", msg = \"Failed for 'Hello World!!!'\");\n}\n\n@test:Config { }\nfunction testAntiShuffleEmpty() {\n    test:assertEquals(anti_shuffle(\"\"), \"\", msg = \"Failed for empty string\");\n}\n\n@test:Config { }\nfunction testAntiShuffleLongSentence() {\n    test:assertEquals(anti_shuffle(\"Hi. My name is Mister Robot. How are you?\"), \".Hi My aemn is Meirst .Rboot How aer ?ouy\", msg = \"Failed for long sentence\");\n}"
  },
  {
    "id": "request-84",
    "prompt": "You are given a 2-dimensional array as nested arrays, similar to a matrix, but unlike matrices, each row may contain a different number of columns. Given a 2D array `lst` and an integer `x`, find all occurrences of integer `x` in the array and return an array of coordinate tuples `[[x1, y1], [x2, y2] ...]` where each tuple represents a coordinate (row, column), starting with index 0. Sort coordinates first by rows in ascending order, then sort coordinates within the same row by columns in descending order.\n\nExamples:\n```ballerina\n// get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) \n// returns [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n\n// get_row([], 1) \n// returns []\n\n// get_row([[], [1], [1, 2, 3]], 3) \n// returns [[2, 2]]\n```\n\nWrite a function with this signature:\n```ballerina\nfunction get_row(lst int[][], x int) returns int[][]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGetRowBasic() {\n    int[][] result = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1);\n    int[][] expected = [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]];\n    test:assertEquals(result, expected, msg = \"Basic test case failed\");\n}\n\n@test:Config { }\nfunction testGetRowSameValue() {\n    int[][] result = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2);\n    int[][] expected = [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]];\n    test:assertEquals(result, expected, msg = \"Same value in multiple rows test failed\");\n}\n\n@test:Config { }\nfunction testGetRowMultipleOccurrences() {\n    int[][] result = get_row([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1);\n    int[][] expected = [[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]];\n    test:assertEquals(result, expected, msg = \"Multiple occurrences test failed\");\n}\n\n@test:Config { }\nfunction testGetRowEmptyArray() {\n    int[][] result = get_row([], 1);\n    int[][] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testGetRowNotFound() {\n    int[][] result = get_row([[1]], 2);\n    int[][] expected = [];\n    test:assertEquals(result, expected, msg = \"Value not found test failed\");\n}\n\n@test:Config { }\nfunction testGetRowMixedLengths() {\n    int[][] result = get_row([[], [1], [1, 2, 3]], 3);\n    int[][] expected = [[2, 2]];\n    test:assertEquals(result, expected, msg = \"Mixed lengths test failed\");\n}"
  },
  {
    "id": "request-85",
    "prompt": "Given an array of non-negative integers, return a copy of the given array after sorting. You will sort the given array in ascending order if the sum of the first index value and last index value is odd, or sort it in descending order if the sum of the first index value and last index value is even.\n\nNote: don't change the given array.\n\nExamples:\n- sort_array([]) should return []\n- sort_array([5]) should return [5]\n- sort_array([2, 4, 3, 0, 1, 5]) should return [0, 1, 2, 3, 4, 5]\n- sort_array([2, 4, 3, 0, 1, 5, 6]) should return [6, 5, 4, 3, 2, 1, 0]\n\nfunction sort_array(array: int[]) returns int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyArray() {\n    int[] result = sort_array([]);\n    test:assertEquals(result, [], msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testSingleElement() {\n    int[] result = sort_array([5]);\n    test:assertEquals(result, [5], msg = \"Single element test failed\");\n}\n\n@test:Config { }\nfunction testAscendingSort() {\n    int[] result = sort_array([2, 4, 3, 0, 1, 5]);\n    test:assertEquals(result, [0, 1, 2, 3, 4, 5], msg = \"Ascending sort test failed\");\n}\n\n@test:Config { }\nfunction testDescendingSort() {\n    int[] result = sort_array([2, 4, 3, 0, 1, 5, 6]);\n    test:assertEquals(result, [6, 5, 4, 3, 2, 1, 0], msg = \"Descending sort test failed\");\n}\n\n@test:Config { }\nfunction testTwoElements() {\n    int[] result = sort_array([2, 1]);\n    test:assertEquals(result, [1, 2], msg = \"Two elements test failed\");\n}\n\n@test:Config { }\nfunction testAscendingSort2() {\n    int[] result = sort_array([15, 42, 87, 32, 11, 0]);\n    test:assertEquals(result, [0, 11, 15, 32, 42, 87], msg = \"Ascending sort test 2 failed\");\n}\n\n@test:Config { }\nfunction testDescendingSort2() {\n    int[] result = sort_array([21, 14, 23, 11]);\n    test:assertEquals(result, [23, 21, 14, 11], msg = \"Descending sort test 2 failed\");\n}"
  },
  {
    "id": "request-86",
    "prompt": "Create a function `encrypt` that takes a string as an argument and returns a string encrypted with the alphabet being rotated. The alphabet should be rotated in a manner such that the letters shift down by two multiplied to two places (4 positions).\n\nFor example:\n// encrypt(\"hi\") should return \"lm\"\n// encrypt(\"asdfghjkl\") should return \"ewhjklnop\" \n// encrypt(\"gf\") should return \"kj\"\n// encrypt(\"et\") should return \"ix\"\n\n```ballerina\nfunction encrypt(s string) returns string {\n    \n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEncrypt1() {\n    test:assertEquals(encrypt(\"hi\"), \"lm\", msg = \"Failed for input 'hi'\");\n}\n\n@test:Config { }\nfunction testEncrypt2() {\n    test:assertEquals(encrypt(\"asdfghjkl\"), \"ewhjklnop\", msg = \"Failed for input 'asdfghjkl'\");\n}\n\n@test:Config { }\nfunction testEncrypt3() {\n    test:assertEquals(encrypt(\"gf\"), \"kj\", msg = \"Failed for input 'gf'\");\n}\n\n@test:Config { }\nfunction testEncrypt4() {\n    test:assertEquals(encrypt(\"et\"), \"ix\", msg = \"Failed for input 'et'\");\n}\n\n@test:Config { }\nfunction testEncrypt5() {\n    test:assertEquals(encrypt(\"faewfawefaewg\"), \"jeiajeaijeiak\", msg = \"Failed for input 'faewfawefaewg'\");\n}\n\n@test:Config { }\nfunction testEncrypt6() {\n    test:assertEquals(encrypt(\"hellomyfriend\"), \"lippsqcjvmirh\", msg = \"Failed for input 'hellomyfriend'\");\n}\n\n@test:Config { }\nfunction testEncrypt7() {\n    test:assertEquals(encrypt(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"), \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\", msg = \"Failed for long input\");\n}\n\n@test:Config { }\nfunction testEncrypt8() {\n    test:assertEquals(encrypt(\"a\"), \"e\", msg = \"Failed for input 'a'\");\n}"
  },
  {
    "id": "request-87",
    "prompt": "You are given an array of integers. Write a function `nextSmallest` that returns the 2nd smallest element of the array. Return `()` if there is no such element.\n\n```ballerina\n// nextSmallest([1, 2, 3, 4, 5]) returns 2\n// nextSmallest([5, 1, 4, 3, 2]) returns 2\n// nextSmallest([]) returns ()\n// nextSmallest([1, 1]) returns ()\n```\n\nfunction nextSmallest(lst int[]) returns int? {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testNextSmallest1() {\n    int? result = nextSmallest([1, 2, 3, 4, 5]);\n    test:assertEquals(result, 2, msg = \"Failed for [1, 2, 3, 4, 5]\");\n}\n\n@test:Config { }\nfunction testNextSmallest2() {\n    int? result = nextSmallest([5, 1, 4, 3, 2]);\n    test:assertEquals(result, 2, msg = \"Failed for [5, 1, 4, 3, 2]\");\n}\n\n@test:Config { }\nfunction testNextSmallestEmpty() {\n    int? result = nextSmallest([]);\n    test:assertEquals(result, (), msg = \"Failed for empty array\");\n}\n\n@test:Config { }\nfunction testNextSmallestDuplicates() {\n    int? result = nextSmallest([1, 1]);\n    test:assertEquals(result, (), msg = \"Failed for [1, 1]\");\n}\n\n@test:Config { }\nfunction testNextSmallestWithZero() {\n    int? result = nextSmallest([1, 1, 1, 1, 0]);\n    test:assertEquals(result, 1, msg = \"Failed for [1, 1, 1, 1, 0]\");\n}\n\n@test:Config { }\nfunction testNextSmallestDuplicates2() {\n    int? result = nextSmallest([1, 1]);\n    test:assertEquals(result, (), msg = \"Failed for [1, 1] second test\");\n}\n\n@test:Config { }\nfunction testNextSmallestNegative() {\n    int? result = nextSmallest([-35, 34, 12, -45]);\n    test:assertEquals(result, -35, msg = \"Failed for [-35, 34, 12, -45]\");\n}"
  },
  {
    "id": "request-88",
    "prompt": "You'll be given a string of words, and your task is to count the number of boredoms. A boredom is a sentence that starts with the word \"I\". Sentences are delimited by '.', '?' or '!'.\n\nFor example:\n- is_bored(\"Hello world\") should return 0\n- is_bored(\"The sky is blue. The sun is shining. I love this weather\") should return 1\n\nfunction is_bored(S string) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsBored() {\n    test:assertEquals(is_bored(\"Hello world\"), 0);\n    test:assertEquals(is_bored(\"Is the sky blue?\"), 0);\n    test:assertEquals(is_bored(\"I love It !\"), 1);\n    test:assertEquals(is_bored(\"bIt\"), 0);\n    test:assertEquals(is_bored(\"I feel good today. I will be productive. will kill It\"), 2);\n    test:assertEquals(is_bored(\"You and I are going for a walk\"), 0);\n}"
  },
  {
    "id": "request-89",
    "prompt": "Create a function that takes 3 numbers and returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. Returns false in any other cases.\n\n```ballerina\nfunction any_int(float x, float y, float z) returns boolean {\n    // Your implementation here\n}\n```\n\nExamples:\n// any_int(5, 2, 7) returns true\n// any_int(3, 2, 2) returns false  \n// any_int(3, -2, 1) returns true\n// any_int(3.6, -2.2, 2) returns false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAnyInt1() {\n    boolean result = any_int(2, 3, 1);\n    test:assertTrue(result, msg = \"any_int(2, 3, 1) should return true\");\n}\n\n@test:Config { }\nfunction testAnyInt2() {\n    boolean result = any_int(2.5, 2, 3);\n    test:assertFalse(result, msg = \"any_int(2.5, 2, 3) should return false\");\n}\n\n@test:Config { }\nfunction testAnyInt3() {\n    boolean result = any_int(1.5, 5, 3.5);\n    test:assertFalse(result, msg = \"any_int(1.5, 5, 3.5) should return false\");\n}\n\n@test:Config { }\nfunction testAnyInt4() {\n    boolean result = any_int(2, 6, 2);\n    test:assertFalse(result, msg = \"any_int(2, 6, 2) should return false\");\n}\n\n@test:Config { }\nfunction testAnyInt5() {\n    boolean result = any_int(4, 2, 2);\n    test:assertTrue(result, msg = \"any_int(4, 2, 2) should return true\");\n}\n\n@test:Config { }\nfunction testAnyInt6() {\n    boolean result = any_int(2.2, 2.2, 2.2);\n    test:assertFalse(result, msg = \"any_int(2.2, 2.2, 2.2) should return false\");\n}\n\n@test:Config { }\nfunction testAnyInt7() {\n    boolean result = any_int(-4, 6, 2);\n    test:assertTrue(result, msg = \"any_int(-4, 6, 2) should return true\");\n}\n\n@test:Config { }\nfunction testAnyInt8() {\n    boolean result = any_int(2, 1, 1);\n    test:assertTrue(result, msg = \"any_int(2, 1, 1) should return true\");\n}\n\n@test:Config { }\nfunction testAnyInt9() {\n    boolean result = any_int(3, 4, 7);\n    test:assertTrue(result, msg = \"any_int(3, 4, 7) should return true\");\n}\n\n@test:Config { }\nfunction testAnyInt10() {\n    boolean result = any_int(3.0, 4, 7);\n    test:assertFalse(result, msg = \"any_int(3.0, 4, 7) should return false\");\n}"
  },
  {
    "id": "request-90",
    "prompt": "Write a function that takes a message and encodes it by swapping the case of all letters and replacing all vowels with the letter that appears 2 places ahead of that vowel in the English alphabet. Assume the input contains only letters and spaces.\n\nFor vowel replacement:\n- 'a' or 'A' becomes 'c' or 'C'\n- 'e' or 'E' becomes 'g' or 'G' \n- 'i' or 'I' becomes 'k' or 'K'\n- 'o' or 'O' becomes 'q' or 'Q'\n- 'u' or 'U' becomes 'w' or 'W'\n\nExamples:\n// encode(\"test\") returns \"TGST\"\n// encode(\"This is a message\") returns \"tHKS KS C MGSSCGG\"\n\nfunction encode(message string) returns string {\n    // Implementation goes here\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testEncode1() {\n    test:assertEquals(encode(\"TEST\"), \"tgst\", msg = \"Failed for TEST\");\n}\n\n@test:Config {}\nfunction testEncode2() {\n    test:assertEquals(encode(\"Mudasir\"), \"mWDCSKR\", msg = \"Failed for Mudasir\");\n}\n\n@test:Config {}\nfunction testEncode3() {\n    test:assertEquals(encode(\"YES\"), \"ygs\", msg = \"Failed for YES\");\n}\n\n@test:Config {}\nfunction testEncode4() {\n    test:assertEquals(encode(\"This is a message\"), \"tHKS KS C MGSSCGG\", msg = \"Failed for 'This is a message'\");\n}\n\n@test:Config {}\nfunction testEncode5() {\n    test:assertEquals(encode(\"I DoNt KnOw WhAt tO WrItE\"), \"k dQnT kNqW wHcT Tq wRkTg\", msg = \"Failed for 'I DoNt KnOw WhAt tO WrItE'\");\n}"
  },
  {
    "id": "request-91",
    "prompt": "You are given an array of integers. You need to find the largest prime value and return the sum of its digits.\n\nExamples:\n// skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]) → 10\n// skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) → 25\n// skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]) → 13\n// skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) → 11\n// skjkasdkd([0, 81, 12, 3, 1, 21]) → 3\n// skjkasdkd([0, 8, 1, 2, 1, 7]) → 7\n\nfunction skjkasdkd(int[] lst) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSkjkasdkd1() {\n    int result = skjkasdkd([0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]);\n    test:assertEquals(result, 10, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd2() {\n    int result = skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]);\n    test:assertEquals(result, 25, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd3() {\n    int result = skjkasdkd([1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]);\n    test:assertEquals(result, 13, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd4() {\n    int result = skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]);\n    test:assertEquals(result, 11, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd5() {\n    int result = skjkasdkd([0, 81, 12, 3, 1, 21]);\n    test:assertEquals(result, 3, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd6() {\n    int result = skjkasdkd([0, 8, 1, 2, 1, 7]);\n    test:assertEquals(result, 7, msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd7() {\n    int result = skjkasdkd([8191]);\n    test:assertEquals(result, 19, msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd8() {\n    int result = skjkasdkd([8191, 123456, 127, 7]);\n    test:assertEquals(result, 19, msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testSkjkasdkd9() {\n    int result = skjkasdkd([127, 97, 8192]);\n    test:assertEquals(result, 10, msg = \"Test case 9 failed\");\n}"
  },
  {
    "id": "request-92",
    "prompt": "Given a map, return true if all keys are strings in lower case or all keys are strings in upper case, else return false. The function should return false if the given map is empty.\n\nExamples:\n// check_dict_case({\"a\": \"apple\", \"b\": \"banana\"}) returns true\n// check_dict_case({\"a\": \"apple\", \"A\": \"banana\", \"B\": \"banana\"}) returns false\n// check_dict_case({\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"}) returns false\n// check_dict_case({\"STATE\": \"NC\", \"ZIP\": \"12345\"}) returns true\n\nfunction check_dict_case(dict: map<string>) returns boolean {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCheckDictCase1() {\n    map<string> dict = {\"p\": \"pineapple\", \"b\": \"banana\"};\n    boolean result = check_dict_case(dict);\n    test:assertTrue(result, msg = \"Failed for all lowercase keys\");\n}\n\n@test:Config { }\nfunction testCheckDictCase2() {\n    map<string> dict = {\"p\": \"pineapple\", \"A\": \"banana\", \"B\": \"banana\"};\n    boolean result = check_dict_case(dict);\n    test:assertFalse(result, msg = \"Failed for mixed case keys\");\n}\n\n@test:Config { }\nfunction testCheckDictCase3() {\n    map<string> dict = {\"p\": \"pineapple\", \"5\": \"banana\", \"a\": \"apple\"};\n    boolean result = check_dict_case(dict);\n    test:assertFalse(result, msg = \"Failed for keys with numbers\");\n}\n\n@test:Config { }\nfunction testCheckDictCase4() {\n    map<string> dict = {\"Name\": \"John\", \"Age\": \"36\", \"City\": \"Houston\"};\n    boolean result = check_dict_case(dict);\n    test:assertFalse(result, msg = \"Failed for capitalized keys\");\n}\n\n@test:Config { }\nfunction testCheckDictCase5() {\n    map<string> dict = {\"STATE\": \"NC\", \"ZIP\": \"12345\"};\n    boolean result = check_dict_case(dict);\n    test:assertTrue(result, msg = \"Failed for all uppercase keys\");\n}\n\n@test:Config { }\nfunction testCheckDictCase6() {\n    map<string> dict = {\"fruit\": \"Orange\", \"taste\": \"Sweet\"};\n    boolean result = check_dict_case(dict);\n    test:assertTrue(result, msg = \"Failed for all lowercase keys\");\n}\n\n@test:Config { }\nfunction testCheckDictCase7() {\n    map<string> dict = {};\n    boolean result = check_dict_case(dict);\n    test:assertFalse(result, msg = \"Failed for empty map\");\n}"
  },
  {
    "id": "request-93",
    "prompt": "Implement a function that takes a non-negative integer and returns an array of all prime numbers that are less than n.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\nFor example:\n- count_up_to(5) should return [2, 3] (primes less than 5)\n- count_up_to(11) should return [2, 3, 5, 7] (primes less than 11)\n- count_up_to(0) should return [] (no primes less than 0)\n- count_up_to(20) should return [2, 3, 5, 7, 11, 13, 17, 19] (primes less than 20)\n- count_up_to(1) should return [] (no primes less than 1)\n- count_up_to(18) should return [2, 3, 5, 7, 11, 13, 17] (primes less than 18)\n\nfunction count_up_to(n int) int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testCountUpTo5() {\n    int[] result = count_up_to(5);\n    int[] expected = [2, 3];\n    test:assertEquals(result, expected, msg = \"Failed for n=5\");\n}\n\n@test:Config {}\nfunction testCountUpTo6() {\n    int[] result = count_up_to(6);\n    int[] expected = [2, 3, 5];\n    test:assertEquals(result, expected, msg = \"Failed for n=6\");\n}\n\n@test:Config {}\nfunction testCountUpTo7() {\n    int[] result = count_up_to(7);\n    int[] expected = [2, 3, 5];\n    test:assertEquals(result, expected, msg = \"Failed for n=7\");\n}\n\n@test:Config {}\nfunction testCountUpTo10() {\n    int[] result = count_up_to(10);\n    int[] expected = [2, 3, 5, 7];\n    test:assertEquals(result, expected, msg = \"Failed for n=10\");\n}\n\n@test:Config {}\nfunction testCountUpTo0() {\n    int[] result = count_up_to(0);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for n=0\");\n}\n\n@test:Config {}\nfunction testCountUpTo22() {\n    int[] result = count_up_to(22);\n    int[] expected = [2, 3, 5, 7, 11, 13, 17, 19];\n    test:assertEquals(result, expected, msg = \"Failed for n=22\");\n}\n\n@test:Config {}\nfunction testCountUpTo1() {\n    int[] result = count_up_to(1);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for n=1\");\n}\n\n@test:Config {}\nfunction testCountUpTo18() {\n    int[] result = count_up_to(18);\n    int[] expected = [2, 3, 5, 7, 11, 13, 17];\n    test:assertEquals(result, expected, msg = \"Failed for n=18\");\n}\n\n@test:Config {}\nfunction testCountUpTo47() {\n    int[] result = count_up_to(47);\n    int[] expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43];\n    test:assertEquals(result, expected, msg = \"Failed for n=47\");\n}\n\n@test:Config {}\nfunction testCountUpTo101() {\n    int[] result = count_up_to(101);\n    int[] expected = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    test:assertEquals(result, expected, msg = \"Failed for n=101\");\n}"
  },
  {
    "id": "request-94",
    "prompt": "Complete the function that takes two integers and returns the product of their unit digits. The unit digit is the rightmost digit of a number. For negative numbers, consider only the absolute value when finding the unit digit.\n\nExamples:\n- multiply(148, 412) should return 16 (8 * 2 = 16)\n- multiply(19, 28) should return 72 (9 * 8 = 72)\n- multiply(2020, 1851) should return 0 (0 * 1 = 0)\n- multiply(14, -15) should return 20 (4 * 5 = 20)\n\nfunction multiply(a int, b int) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMultiply1() {\n    int result = multiply(148, 412);\n    test:assertEquals(result, 16, msg = \"multiply(148, 412) should return 16\");\n}\n\n@test:Config { }\nfunction testMultiply2() {\n    int result = multiply(19, 28);\n    test:assertEquals(result, 72, msg = \"multiply(19, 28) should return 72\");\n}\n\n@test:Config { }\nfunction testMultiply3() {\n    int result = multiply(2020, 1851);\n    test:assertEquals(result, 0, msg = \"multiply(2020, 1851) should return 0\");\n}\n\n@test:Config { }\nfunction testMultiply4() {\n    int result = multiply(14, -15);\n    test:assertEquals(result, 20, msg = \"multiply(14, -15) should return 20\");\n}\n\n@test:Config { }\nfunction testMultiply5() {\n    int result = multiply(76, 67);\n    test:assertEquals(result, 42, msg = \"multiply(76, 67) should return 42\");\n}\n\n@test:Config { }\nfunction testMultiply6() {\n    int result = multiply(17, 27);\n    test:assertEquals(result, 49, msg = \"multiply(17, 27) should return 49\");\n}\n\n@test:Config { }\nfunction testMultiply7() {\n    int result = multiply(0, 1);\n    test:assertEquals(result, 0, msg = \"multiply(0, 1) should return 0\");\n}\n\n@test:Config { }\nfunction testMultiply8() {\n    int result = multiply(0, 0);\n    test:assertEquals(result, 0, msg = \"multiply(0, 0) should return 0\");\n}"
  },
  {
    "id": "request-95",
    "prompt": "Given a string s, count the number of uppercase vowels in even indices.\n\nFor example:\n// count_upper(\"aBCdEf\") returns 1\n// count_upper(\"abcdefg\") returns 0  \n// count_upper(\"dBBE\") returns 0\n\nfunction count_upper(s string) int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCountUpper1() {\n    int result = count_upper(\"aBCdEf\");\n    test:assertEquals(result, 1, msg = \"Failed for input 'aBCdEf'\");\n}\n\n@test:Config { }\nfunction testCountUpper2() {\n    int result = count_upper(\"abcdefg\");\n    test:assertEquals(result, 0, msg = \"Failed for input 'abcdefg'\");\n}\n\n@test:Config { }\nfunction testCountUpper3() {\n    int result = count_upper(\"dBBE\");\n    test:assertEquals(result, 0, msg = \"Failed for input 'dBBE'\");\n}\n\n@test:Config { }\nfunction testCountUpper4() {\n    int result = count_upper(\"B\");\n    test:assertEquals(result, 0, msg = \"Failed for input 'B'\");\n}\n\n@test:Config { }\nfunction testCountUpper5() {\n    int result = count_upper(\"U\");\n    test:assertEquals(result, 1, msg = \"Failed for input 'U'\");\n}\n\n@test:Config { }\nfunction testCountUpper6() {\n    int result = count_upper(\"\");\n    test:assertEquals(result, 0, msg = \"Failed for input ''\");\n}\n\n@test:Config { }\nfunction testCountUpper7() {\n    int result = count_upper(\"EEEE\");\n    test:assertEquals(result, 2, msg = \"Failed for input 'EEEE'\");\n}"
  },
  {
    "id": "request-96",
    "prompt": "Create a function that takes a value (string) representing a number and returns the closest integer to it. If the number is equidistant from two integers, round it away from zero.\n\nRounding away from zero means that if the given number is equidistant from two integers, the one you should return is the one that is the farthest from zero. For example closest_integer(\"14.5\") should return 15 and closest_integer(\"-14.5\") should return -15.\n\n```ballerina\nfunction closest_integer(value string) returns int {\n    // Your implementation here\n}\n```\n\nExpected function calls:\n```ballerina\nclosest_integer(\"10\") // 10\nclosest_integer(\"14.5\") // 15\nclosest_integer(\"-15.5\") // -16\nclosest_integer(\"15.3\") // 15\nclosest_integer(\"0\") // 0\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testClosestInteger() {\n    test:assertEquals(closest_integer(\"10\"), 10, msg = \"Failed for '10'\");\n    test:assertEquals(closest_integer(\"14.5\"), 15, msg = \"Failed for '14.5'\");\n    test:assertEquals(closest_integer(\"-15.5\"), -16, msg = \"Failed for '-15.5'\");\n    test:assertEquals(closest_integer(\"15.3\"), 15, msg = \"Failed for '15.3'\");\n    test:assertEquals(closest_integer(\"0\"), 0, msg = \"Failed for '0'\");\n}"
  },
  {
    "id": "request-97",
    "prompt": "Given a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n- the next odd number if n is odd.\n- the next even number if n is even.\nReturn the number of stones in each level in an array, where element at index i represents the number of stones in the level (i+1).\n\nFor example:\n- make_a_pile(3) should return [3, 5, 7]\n- make_a_pile(4) should return [4, 6, 8, 10]\n\nfunction make_a_pile(n int) int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMakeAPile3() {\n    int[] expected = [3, 5, 7];\n    int[] result = make_a_pile(3);\n    test:assertEquals(result, expected, msg = \"Failed for n=3\");\n}\n\n@test:Config { }\nfunction testMakeAPile4() {\n    int[] expected = [4, 6, 8, 10];\n    int[] result = make_a_pile(4);\n    test:assertEquals(result, expected, msg = \"Failed for n=4\");\n}\n\n@test:Config { }\nfunction testMakeAPile5() {\n    int[] expected = [5, 7, 9, 11, 13];\n    int[] result = make_a_pile(5);\n    test:assertEquals(result, expected, msg = \"Failed for n=5\");\n}\n\n@test:Config { }\nfunction testMakeAPile6() {\n    int[] expected = [6, 8, 10, 12, 14, 16];\n    int[] result = make_a_pile(6);\n    test:assertEquals(result, expected, msg = \"Failed for n=6\");\n}\n\n@test:Config { }\nfunction testMakeAPile8() {\n    int[] expected = [8, 10, 12, 14, 16, 18, 20, 22];\n    int[] result = make_a_pile(8);\n    test:assertEquals(result, expected, msg = \"Failed for n=8\");\n}"
  },
  {
    "id": "request-98",
    "prompt": "// You will be given a string of words separated by commas or spaces. Your task is\n// to split the string into words and return an array of the words.\n// For example:\n// words_string(\"Hi, my name is John\") should return [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n// words_string(\"One, two, three, four, five, six\") should return [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\nfunction words_string(s: string) returns string[] {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testWordsStringBasic() {\n    string[] result = words_string(\"Hi, my name is John\");\n    string[] expected = [\"Hi\", \"my\", \"name\", \"is\", \"John\"];\n    test:assertEquals(result, expected, msg = \"Basic comma and space separation failed\");\n}\n\n@test:Config { }\nfunction testWordsStringCommaOnly() {\n    string[] result = words_string(\"One, two, three, four, five, six\");\n    string[] expected = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\n    test:assertEquals(result, expected, msg = \"Comma separation failed\");\n}\n\n@test:Config { }\nfunction testWordsStringShort() {\n    string[] result = words_string(\"Hi, my name\");\n    string[] expected = [\"Hi\", \"my\", \"name\"];\n    test:assertEquals(result, expected, msg = \"Short string separation failed\");\n}\n\n@test:Config { }\nfunction testWordsStringMultipleCommas() {\n    string[] result = words_string(\"One,, two, three, four, five, six,\");\n    string[] expected = [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"];\n    test:assertEquals(result, expected, msg = \"Multiple commas and trailing comma handling failed\");\n}\n\n@test:Config { }\nfunction testWordsStringEmpty() {\n    string[] result = words_string(\"\");\n    string[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty string handling failed\");\n}\n\n@test:Config { }\nfunction testWordsStringExtraSpaces() {\n    string[] result = words_string(\"ahmed     , gamal\");\n    string[] expected = [\"ahmed\", \"gamal\"];\n    test:assertEquals(result, expected, msg = \"Extra spaces handling failed\");\n}"
  },
  {
    "id": "request-99",
    "prompt": "Write a function that takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n\n```ballerina\nfunction choose_num(int x, int y) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n- choose_num(12, 15) should return 14\n- choose_num(13, 12) should return -1",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testChooseNum1() {\n    test:assertEquals(choose_num(12, 15), 14, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum2() {\n    test:assertEquals(choose_num(13, 12), -1, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum3() {\n    test:assertEquals(choose_num(33, 12354), 12354, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum4() {\n    test:assertEquals(choose_num(5234, 5233), -1, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum5() {\n    test:assertEquals(choose_num(6, 29), 28, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum6() {\n    test:assertEquals(choose_num(27, 10), -1, msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum7() {\n    test:assertEquals(choose_num(7, 7), -1, msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testChooseNum8() {\n    test:assertEquals(choose_num(546, 546), 546, msg = \"Test case 8 failed\");\n}"
  },
  {
    "id": "request-100",
    "prompt": "You are given two positive integers n and m, and your task is to compute the average of the integers from n through m (including n and m). Round the answer to the nearest integer and convert that to binary. If n is greater than m, return -1.\n\nExample:\n- rounded_avg(1, 5) returns \"0b11\"\n- rounded_avg(7, 5) returns -1  \n- rounded_avg(10, 20) returns \"0b1111\"\n- rounded_avg(20, 33) returns \"0b11010\"\n\nfunction rounded_avg(int n, int m) returns string|int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testRoundedAvg1() {\n    string|int result = rounded_avg(1, 5);\n    test:assertEquals(result, \"0b11\", msg = \"Failed for range 1 to 5\");\n}\n\n@test:Config { }\nfunction testRoundedAvg2() {\n    string|int result = rounded_avg(7, 13);\n    test:assertEquals(result, \"0b1010\", msg = \"Failed for range 7 to 13\");\n}\n\n@test:Config { }\nfunction testRoundedAvg3() {\n    string|int result = rounded_avg(964, 977);\n    test:assertEquals(result, \"0b1111001010\", msg = \"Failed for range 964 to 977\");\n}\n\n@test:Config { }\nfunction testRoundedAvg4() {\n    string|int result = rounded_avg(996, 997);\n    test:assertEquals(result, \"0b1111100100\", msg = \"Failed for range 996 to 997\");\n}\n\n@test:Config { }\nfunction testRoundedAvg5() {\n    string|int result = rounded_avg(560, 851);\n    test:assertEquals(result, \"0b1011000010\", msg = \"Failed for range 560 to 851\");\n}\n\n@test:Config { }\nfunction testRoundedAvg6() {\n    string|int result = rounded_avg(185, 546);\n    test:assertEquals(result, \"0b101101110\", msg = \"Failed for range 185 to 546\");\n}\n\n@test:Config { }\nfunction testRoundedAvg7() {\n    string|int result = rounded_avg(362, 496);\n    test:assertEquals(result, \"0b110101101\", msg = \"Failed for range 362 to 496\");\n}\n\n@test:Config { }\nfunction testRoundedAvg8() {\n    string|int result = rounded_avg(350, 902);\n    test:assertEquals(result, \"0b1001110010\", msg = \"Failed for range 350 to 902\");\n}\n\n@test:Config { }\nfunction testRoundedAvg9() {\n    string|int result = rounded_avg(197, 233);\n    test:assertEquals(result, \"0b11010111\", msg = \"Failed for range 197 to 233\");\n}\n\n@test:Config { }\nfunction testRoundedAvgInvalidRange1() {\n    string|int result = rounded_avg(7, 5);\n    test:assertEquals(result, -1, msg = \"Failed for invalid range 7 to 5\");\n}\n\n@test:Config { }\nfunction testRoundedAvgInvalidRange2() {\n    string|int result = rounded_avg(5, 1);\n    test:assertEquals(result, -1, msg = \"Failed for invalid range 5 to 1\");\n}\n\n@test:Config { }\nfunction testRoundedAvgSameNumber() {\n    string|int result = rounded_avg(5, 5);\n    test:assertEquals(result, \"0b101\", msg = \"Failed for same number 5\");\n}"
  },
  {
    "id": "request-101",
    "prompt": "Given an array of positive integers, return a sorted array of all elements that don't contain any even digits (0, 2, 4, 6, 8).\n\nThe returned array should be sorted in increasing order.\n\nFor example:\n- unique_digits([15, 33, 1422, 1]) should return [1, 15, 33]\n- unique_digits([152, 323, 1422, 10]) should return []\n\n```ballerina\nfunction unique_digits(x int[]) returns int[] {\n    // Your implementation here\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testUniqueDigits1() {\n    int[] result = unique_digits([15, 33, 1422, 1]);\n    int[] expected = [1, 15, 33];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testUniqueDigits2() {\n    int[] result = unique_digits([152, 323, 1422, 10]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testUniqueDigits3() {\n    int[] result = unique_digits([12345, 2033, 111, 151]);\n    int[] expected = [111, 151];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testUniqueDigits4() {\n    int[] result = unique_digits([135, 103, 31]);\n    int[] expected = [31, 135];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}"
  },
  {
    "id": "request-102",
    "prompt": "Given an array of integers, sort the integers that are between 1 and 9 inclusive, reverse the resulting array, and then replace each digit by its corresponding name from \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\nFor example:\n- by_length([2, 1, 1, 4, 5, 8, 2, 3]) should return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n- If the array is empty, return an empty array: by_length([]) should return []\n- If the array has any strange number ignore it: by_length([1, -1, 55]) should return [\"One\"]\n\nfunction by_length(arr int[]) returns string[]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testByLengthBasicCase() {\n    int[] input = [2, 1, 1, 4, 5, 8, 2, 3];\n    string[] expected = [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"];\n    string[] result = by_length(input);\n    test:assertEquals(result, expected, msg = \"Basic case failed\");\n}\n\n@test:Config { }\nfunction testByLengthEmptyArray() {\n    int[] input = [];\n    string[] expected = [];\n    string[] result = by_length(input);\n    test:assertEquals(result, expected, msg = \"Empty array case failed\");\n}\n\n@test:Config { }\nfunction testByLengthWithInvalidNumbers() {\n    int[] input = [1, -1, 55];\n    string[] expected = [\"One\"];\n    string[] result = by_length(input);\n    test:assertEquals(result, expected, msg = \"Invalid numbers case failed\");\n}\n\n@test:Config { }\nfunction testByLengthMixedValidInvalid() {\n    int[] input = [1, -1, 3, 2];\n    string[] expected = [\"Three\", \"Two\", \"One\"];\n    string[] result = by_length(input);\n    test:assertEquals(result, expected, msg = \"Mixed valid/invalid case failed\");\n}\n\n@test:Config { }\nfunction testByLengthHighNumbers() {\n    int[] input = [9, 4, 8];\n    string[] expected = [\"Nine\", \"Eight\", \"Four\"];\n    string[] result = by_length(input);\n    test:assertEquals(result, expected, msg = \"High numbers case failed\");\n}"
  },
  {
    "id": "request-103",
    "prompt": "Implement the function f that takes n as a parameter and returns an array of size n. For each position i (starting from 1), if i is even, store the factorial of i, otherwise store the sum of numbers from 1 to i.\n\nThe factorial of i is the multiplication of numbers from 1 to i (1 * 2 * ... * i).\nThe sum from 1 to i is (1 + 2 + ... + i).\n\n```ballerina\nfunction f(int n) returns int[] {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- f(5) should return [1, 2, 6, 24, 15]\n- f(7) should return [1, 2, 6, 24, 15, 720, 28]\n- f(1) should return [1]\n- f(3) should return [1, 2, 6]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testF5() {\n    int[] result = f(5);\n    int[] expected = [1, 2, 6, 24, 15];\n    test:assertEquals(result, expected, msg = \"f(5) failed\");\n}\n\n@test:Config { }\nfunction testF7() {\n    int[] result = f(7);\n    int[] expected = [1, 2, 6, 24, 15, 720, 28];\n    test:assertEquals(result, expected, msg = \"f(7) failed\");\n}\n\n@test:Config { }\nfunction testF1() {\n    int[] result = f(1);\n    int[] expected = [1];\n    test:assertEquals(result, expected, msg = \"f(1) failed\");\n}\n\n@test:Config { }\nfunction testF3() {\n    int[] result = f(3);\n    int[] expected = [1, 2, 6];\n    test:assertEquals(result, expected, msg = \"f(3) failed\");\n}"
  },
  {
    "id": "request-104",
    "prompt": "Given a positive integer n, return an array that has the number of even and odd integer palindromes that fall within the range(1, n), inclusive.\n\nExample 1:\neven_odd_palindrome(3) should return [1, 2]\n// Integer palindromes are 1, 2, 3. One of them is even, and two of them are odd.\n\nExample 2:\neven_odd_palindrome(12) should return [4, 6]\n// Integer palindromes are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. Four of them are even, and 6 of them are odd.\n\nNote:\n1. 1 <= n <= 10^3\n2. returned array has the number of even and odd integer palindromes respectively.\n\nfunction even_odd_palindrome(int n) returns [int, int] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testEvenOddPalindrome1() {\n    [int, int] result = even_odd_palindrome(123);\n    test:assertEquals(result, [8, 13], msg = \"Failed for n=123\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome2() {\n    [int, int] result = even_odd_palindrome(12);\n    test:assertEquals(result, [4, 6], msg = \"Failed for n=12\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome3() {\n    [int, int] result = even_odd_palindrome(3);\n    test:assertEquals(result, [1, 2], msg = \"Failed for n=3\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome4() {\n    [int, int] result = even_odd_palindrome(63);\n    test:assertEquals(result, [6, 8], msg = \"Failed for n=63\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome5() {\n    [int, int] result = even_odd_palindrome(25);\n    test:assertEquals(result, [5, 6], msg = \"Failed for n=25\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome6() {\n    [int, int] result = even_odd_palindrome(19);\n    test:assertEquals(result, [4, 6], msg = \"Failed for n=19\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome7() {\n    [int, int] result = even_odd_palindrome(9);\n    test:assertEquals(result, [4, 5], msg = \"Failed for n=9\");\n}\n\n@test:Config {}\nfunction testEvenOddPalindrome8() {\n    [int, int] result = even_odd_palindrome(1);\n    test:assertEquals(result, [0, 1], msg = \"Failed for n=1\");\n}"
  },
  {
    "id": "request-105",
    "prompt": "Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.\n\n```ballerina\nfunction count_nums(arr int[]) returns int {\n    // Your implementation here\n}\n```\n\nExample calls:\n```ballerina\ncount_nums([]) // returns 0\ncount_nums([-1, 11, -11]) // returns 1\ncount_nums([1, 1, 2]) // returns 3\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCountNumsEmpty() {\n    int result = count_nums([]);\n    test:assertEquals(result, 0, msg = \"Empty array should return 0\");\n}\n\n@test:Config { }\nfunction testCountNumsNegatives() {\n    int result = count_nums([-1, -2, 0]);\n    test:assertEquals(result, 0, msg = \"Array with negatives and zero should return 0\");\n}\n\n@test:Config { }\nfunction testCountNumsMixed1() {\n    int result = count_nums([1, 1, 2, -2, 3, 4, 5]);\n    test:assertEquals(result, 6, msg = \"Mixed array test 1 failed\");\n}\n\n@test:Config { }\nfunction testCountNumsMixed2() {\n    int result = count_nums([1, 6, 9, -6, 0, 1, 5]);\n    test:assertEquals(result, 5, msg = \"Mixed array test 2 failed\");\n}\n\n@test:Config { }\nfunction testCountNumsMixed3() {\n    int result = count_nums([1, 100, 98, -7, 1, -1]);\n    test:assertEquals(result, 4, msg = \"Mixed array test 3 failed\");\n}\n\n@test:Config { }\nfunction testCountNumsLargeNumbers() {\n    int result = count_nums([12, 23, 34, -45, -56, 0]);\n    test:assertEquals(result, 5, msg = \"Large numbers test failed\");\n}\n\n@test:Config { }\nfunction testCountNumsZeroAndOne() {\n    int result = count_nums([0, 1]);\n    test:assertEquals(result, 1, msg = \"Zero and one test failed\");\n}\n\n@test:Config { }\nfunction testCountNumsSingleElement() {\n    int result = count_nums([1]);\n    test:assertEquals(result, 1, msg = \"Single element test failed\");\n}"
  },
  {
    "id": "request-106",
    "prompt": "You have an array of N integers that are randomly ordered. Your task is to determine if it's possible to get the array sorted in non-decreasing order by performing right shift operations.\n\nA right shift operation moves all elements of the array one position to the right. The last element wraps around to the first position (index 0).\n\nYou can perform this operation any number of times. Return true if it's possible to sort the array this way, false otherwise. If the array is empty, return true.\n\nThe array is guaranteed to have unique elements.\n\nExamples:\n- move_one_ball([3, 4, 5, 1, 2]) should return true (2 right shifts can sort it)\n- move_one_ball([3, 5, 4, 1, 2]) should return false (cannot be sorted with right shifts)\n\nfunction move_one_ball(arr: int[]) returns boolean {\n    // Your implementation here\n}\n\n// Expected calls:\n// move_one_ball([3, 4, 5, 1, 2]) // true\n// move_one_ball([3, 5, 10, 1, 2]) // true  \n// move_one_ball([4, 3, 1, 2]) // false\n// move_one_ball([3, 5, 4, 1, 2]) // false\n// move_one_ball([]) // true",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMoveOneBall1() {\n    boolean result = move_one_ball([3, 4, 5, 1, 2]);\n    test:assertTrue(result, msg = \"move_one_ball([3, 4, 5, 1, 2]) should return true\");\n}\n\n@test:Config { }\nfunction testMoveOneBall2() {\n    boolean result = move_one_ball([3, 5, 10, 1, 2]);\n    test:assertTrue(result, msg = \"move_one_ball([3, 5, 10, 1, 2]) should return true\");\n}\n\n@test:Config { }\nfunction testMoveOneBall3() {\n    boolean result = move_one_ball([4, 3, 1, 2]);\n    test:assertFalse(result, msg = \"move_one_ball([4, 3, 1, 2]) should return false\");\n}\n\n@test:Config { }\nfunction testMoveOneBall4() {\n    boolean result = move_one_ball([3, 5, 4, 1, 2]);\n    test:assertFalse(result, msg = \"move_one_ball([3, 5, 4, 1, 2]) should return false\");\n}\n\n@test:Config { }\nfunction testMoveOneBallEmpty() {\n    boolean result = move_one_ball([]);\n    test:assertTrue(result, msg = \"move_one_ball([]) should return true\");\n}"
  },
  {
    "id": "request-107",
    "prompt": "You need to implement a function that takes two arrays of integers and determines whether it's possible to exchange elements between them to make the first array contain only even numbers. You can exchange any number of elements between the two arrays.\n\nThe function should return \"YES\" if it's possible to make all elements in the first array even by exchanging elements with the second array, otherwise return \"NO\".\n\nFor example:\n- exchange([1, 2, 3, 4], [1, 2, 3, 4]) should return \"YES\"\n- exchange([1, 2, 3, 4], [1, 5, 3, 4]) should return \"NO\"\n\nfunction exchange(lst1: int[], lst2: int[]) returns string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testExchange1() {\n    test:assertEquals(exchange([1, 2, 3, 4], [1, 2, 3, 4]), \"YES\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testExchange2() {\n    test:assertEquals(exchange([1, 2, 3, 4], [1, 5, 3, 4]), \"NO\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testExchange3() {\n    test:assertEquals(exchange([1, 2, 3, 4], [2, 1, 4, 3]), \"YES\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testExchange4() {\n    test:assertEquals(exchange([5, 7, 3], [2, 6, 4]), \"YES\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testExchange5() {\n    test:assertEquals(exchange([5, 7, 3], [2, 6, 3]), \"NO\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testExchange6() {\n    test:assertEquals(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]), \"NO\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testExchange7() {\n    test:assertEquals(exchange([100, 200], [200, 200]), \"YES\", msg = \"Test case 7 failed\");\n}"
  },
  {
    "id": "request-108",
    "prompt": "Given a string representing space separated lowercase letters, return a map of the letters with the most repetition and their corresponding count. If several letters have the same highest occurrence, return all of them.\n\nExamples:\n- histogram(\"a b c\") should return {\"a\": 1, \"b\": 1, \"c\": 1}\n- histogram(\"a b b a\") should return {\"a\": 2, \"b\": 2}  \n- histogram(\"a b c a b\") should return {\"a\": 2, \"b\": 2}\n- histogram(\"b b b b a\") should return {\"b\": 4}\n- histogram(\"\") should return {}\n\nfunction histogram(test string) returns map<int> {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testHistogramEqualCounts() {\n    map<int> result = histogram(\"a b b a\");\n    map<int> expected = {\"a\": 2, \"b\": 2};\n    test:assertEquals(result, expected, msg = \"Failed for 'a b b a'\");\n}\n\n@test:Config { }\nfunction testHistogramPartialMax() {\n    map<int> result = histogram(\"a b c a b\");\n    map<int> expected = {\"a\": 2, \"b\": 2};\n    test:assertEquals(result, expected, msg = \"Failed for 'a b c a b'\");\n}\n\n@test:Config { }\nfunction testHistogramAllSame() {\n    map<int> result = histogram(\"a b c d g\");\n    map<int> expected = {\"a\": 1, \"b\": 1, \"c\": 1, \"d\": 1, \"g\": 1};\n    test:assertEquals(result, expected, msg = \"Failed for 'a b c d g'\");\n}\n\n@test:Config { }\nfunction testHistogramShortString() {\n    map<int> result = histogram(\"r t g\");\n    map<int> expected = {\"r\": 1, \"t\": 1, \"g\": 1};\n    test:assertEquals(result, expected, msg = \"Failed for 'r t g'\");\n}\n\n@test:Config { }\nfunction testHistogramSingleMax() {\n    map<int> result = histogram(\"b b b b a\");\n    map<int> expected = {\"b\": 4};\n    test:assertEquals(result, expected, msg = \"Failed for 'b b b b a'\");\n}\n\n@test:Config { }\nfunction testHistogramEmptyString() {\n    map<int> result = histogram(\"\");\n    map<int> expected = {};\n    test:assertEquals(result, expected, msg = \"Failed for empty string\");\n}\n\n@test:Config { }\nfunction testHistogramSingleChar() {\n    map<int> result = histogram(\"a\");\n    map<int> expected = {\"a\": 1};\n    test:assertEquals(result, expected, msg = \"Failed for 'a'\");\n}"
  },
  {
    "id": "request-109",
    "prompt": "You have two strings `s` and `c`. Delete all characters in `s` that are equal to any character in `c`, then check if the resulting string is a palindrome. A string is a palindrome if it reads the same backward as forward. Return a tuple containing the result string and a boolean indicating whether it's a palindrome.\n\nFor example:\n- reverse_delete(\"abcde\", \"ae\") should return [\"bcd\", false]\n- reverse_delete(\"abcdef\", \"b\") should return [\"acdef\", false]  \n- reverse_delete(\"abcdedcba\", \"ab\") should return [\"cdedc\", true]\n\n```ballerina\nfunction reverse_delete(s string, c string) returns [string, boolean] {\n    // Your implementation here\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testReverseDelete1() {\n    [string, boolean] result = reverse_delete(\"abcde\", \"ae\");\n    test:assertEquals(result, [\"bcd\", false], msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete2() {\n    [string, boolean] result = reverse_delete(\"abcdef\", \"b\");\n    test:assertEquals(result, [\"acdef\", false], msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete3() {\n    [string, boolean] result = reverse_delete(\"abcdedcba\", \"ab\");\n    test:assertEquals(result, [\"cdedc\", true], msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete4() {\n    [string, boolean] result = reverse_delete(\"dwik\", \"w\");\n    test:assertEquals(result, [\"dik\", false], msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete5() {\n    [string, boolean] result = reverse_delete(\"a\", \"a\");\n    test:assertEquals(result, [\"\", true], msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete6() {\n    [string, boolean] result = reverse_delete(\"abcdedcba\", \"\");\n    test:assertEquals(result, [\"abcdedcba\", true], msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete7() {\n    [string, boolean] result = reverse_delete(\"abcdedcba\", \"v\");\n    test:assertEquals(result, [\"abcdedcba\", true], msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete8() {\n    [string, boolean] result = reverse_delete(\"vabba\", \"v\");\n    test:assertEquals(result, [\"abba\", true], msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testReverseDelete9() {\n    [string, boolean] result = reverse_delete(\"mamma\", \"mia\");\n    test:assertEquals(result, [\"\", true], msg = \"Test case 9 failed\");\n}"
  },
  {
    "id": "request-110",
    "prompt": "Given an array of strings, where each string consists of only digits, return an array. Each element i of the output should be \"the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input.\n\nExamples:\n// odd_count([\"1234567\"])\n// [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n// odd_count([\"3\", \"11111111\"])  \n// [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n\nfunction odd_count(lst string[]) returns string[]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testOddCount1() {\n    string[] result = odd_count([\"1234567\"]);\n    string[] expected = [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testOddCount2() {\n    string[] result = odd_count([\"3\", \"11111111\"]);\n    string[] expected = [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testOddCount3() {\n    string[] result = odd_count([\"271\", \"137\", \"314\"]);\n    string[] expected = [\"the number of odd elements 2n the str2ng 2 of the 2nput.\", \"the number of odd elements 3n the str3ng 3 of the 3nput.\", \"the number of odd elements 2n the str2ng 2 of the 2nput.\"];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}"
  },
  {
    "id": "request-111",
    "prompt": "Given an array of integers, find the minimum sum of any non-empty sub-array. A sub-array is a contiguous sequence of elements within the array.\n\nWrite a function `minSubArraySum` that takes an array of integers and returns the minimum possible sum of any non-empty sub-array.\n\n```ballerina\nfunction minSubArraySum(nums int[]) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n- `minSubArraySum([2, 3, 4, 1, 2, 4])` should return `1` (sub-array [1])\n- `minSubArraySum([-1, -2, -3])` should return `-6` (sub-array [-1, -2, -3])",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testMinSubArraySum1() {\n    test:assertEquals(minSubArraySum([2, 3, 4, 1, 2, 4]), 1);\n}\n\n@test:Config {}\nfunction testMinSubArraySum2() {\n    test:assertEquals(minSubArraySum([-1, -2, -3]), -6);\n}\n\n@test:Config {}\nfunction testMinSubArraySum3() {\n    test:assertEquals(minSubArraySum([-1, -2, -3, 2, -10]), -14);\n}\n\n@test:Config {}\nfunction testMinSubArraySum4() {\n    test:assertEquals(minSubArraySum([-9999999999999999]), -9999999999999999);\n}\n\n@test:Config {}\nfunction testMinSubArraySum5() {\n    test:assertEquals(minSubArraySum([0, 10, 20, 1000000]), 0);\n}\n\n@test:Config {}\nfunction testMinSubArraySum6() {\n    test:assertEquals(minSubArraySum([-1, -2, -3, 10, -5]), -6);\n}\n\n@test:Config {}\nfunction testMinSubArraySum7() {\n    test:assertEquals(minSubArraySum([100, -1, -2, -3, 10, -5]), -6);\n}\n\n@test:Config {}\nfunction testMinSubArraySum8() {\n    test:assertEquals(minSubArraySum([10, 11, 13, 8, 3, 4]), 3);\n}\n\n@test:Config {}\nfunction testMinSubArraySum9() {\n    test:assertEquals(minSubArraySum([100, -33, 32, -1, 0, -2]), -33);\n}\n\n@test:Config {}\nfunction testMinSubArraySum10() {\n    test:assertEquals(minSubArraySum([-10]), -10);\n}\n\n@test:Config {}\nfunction testMinSubArraySum11() {\n    test:assertEquals(minSubArraySum([7]), 7);\n}\n\n@test:Config {}\nfunction testMinSubArraySum12() {\n    test:assertEquals(minSubArraySum([1, -1]), -1);\n}"
  },
  {
    "id": "request-112",
    "prompt": "You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets.\n\nWrite a function that takes a 2D array of integers (grid) where each row represents a well and each element is either 0 (no water) or 1 (water unit), and a capacity integer representing the bucket capacity. Return the total number of bucket operations needed.\n\n```ballerina\nfunction maxFill(int[][] grid, int capacity) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n- maxFill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) should return 6\n- maxFill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2) should return 5  \n- maxFill([[0, 0, 0], [0, 0, 0]], 5) should return 0",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMaxFill1() {\n    int result = maxFill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1);\n    test:assertEquals(result, 6, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testMaxFill2() {\n    int result = maxFill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2);\n    test:assertEquals(result, 5, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testMaxFill3() {\n    int result = maxFill([[0, 0, 0], [0, 0, 0]], 5);\n    test:assertEquals(result, 0, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testMaxFill4() {\n    int result = maxFill([[1, 1, 1, 1], [1, 1, 1, 1]], 2);\n    test:assertEquals(result, 4, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testMaxFill5() {\n    int result = maxFill([[1, 1, 1, 1], [1, 1, 1, 1]], 9);\n    test:assertEquals(result, 2, msg = \"Test case 5 failed\");\n}"
  },
  {
    "id": "request-113",
    "prompt": "Sort an array of integers according to the number of ones in their binary representation in ascending order. For numbers with the same number of ones, sort them based on their decimal value in ascending order.\n\nWrite a function `sortArray` that takes an array of integers and returns a new sorted array.\n\nExamples:\n// sortArray([1, 5, 2, 3, 4]) returns [1, 2, 4, 3, 5]\n// sortArray([-2, -3, -4, -5, -6]) returns [-4, -2, -6, -5, -3] \n// sortArray([1, 0, 2, 3, 4]) returns [0, 1, 2, 4, 3]\n\nfunction sortArray(arr: int[]) returns int[]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSortArray1() {\n    int[] result = sortArray([1, 5, 2, 3, 4]);\n    int[] expected = [1, 2, 4, 3, 5];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSortArray2() {\n    int[] result = sortArray([-2, -3, -4, -5, -6]);\n    int[] expected = [-4, -2, -6, -5, -3];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSortArray3() {\n    int[] result = sortArray([1, 0, 2, 3, 4]);\n    int[] expected = [0, 1, 2, 4, 3];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSortArrayEmpty() {\n    int[] result = sortArray([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testSortArray4() {\n    int[] result = sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]);\n    int[] expected = [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testSortArray5() {\n    int[] result = sortArray([3, 6, 44, 12, 32, 5]);\n    int[] expected = [32, 3, 5, 6, 12, 44];\n    test:assertEquals(result, expected, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testSortArray6() {\n    int[] result = sortArray([2, 4, 8, 16, 32]);\n    int[] expected = [2, 4, 8, 16, 32];\n    test:assertEquals(result, expected, msg = \"Test case 6 failed\");\n}"
  },
  {
    "id": "request-114",
    "prompt": "Given a string s and a natural number n, implement a function that returns an array of all words from string s that contain exactly n consonants, in the order these words appear in the string s.\n\nIf the string s is empty then the function should return an empty array.\n\nNote: you may assume the input string contains only letters and spaces.\n\nExamples:\nselect_words(\"Mary had a little lamb\", 4) should return [\"little\"]\nselect_words(\"Mary had a little lamb\", 3) should return [\"Mary\", \"lamb\"] \nselect_words(\"simple white space\", 2) should return []\nselect_words(\"Hello world\", 4) should return [\"world\"]\nselect_words(\"Uncle sam\", 3) should return [\"Uncle\"]\n\nfunction select_words(s string, n int) returns string[]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSelectWords() {\n    test:assertEquals(select_words(\"Mary had a little lamb\", 4), [\"little\"], msg = \"Failed for case 1\");\n    test:assertEquals(select_words(\"Mary had a little lamb\", 3), [\"Mary\", \"lamb\"], msg = \"Failed for case 2\");\n    test:assertEquals(select_words(\"simple white space\", 2), [], msg = \"Failed for case 3\");\n    test:assertEquals(select_words(\"Hello world\", 4), [\"world\"], msg = \"Failed for case 4\");\n    test:assertEquals(select_words(\"Uncle sam\", 3), [\"Uncle\"], msg = \"Failed for case 5\");\n    test:assertEquals(select_words(\"\", 4), [], msg = \"Failed for empty string\");\n    test:assertEquals(select_words(\"a b c d e f\", 1), [\"b\", \"c\", \"d\", \"f\"], msg = \"Failed for single consonant case\");\n}"
  },
  {
    "id": "request-115",
    "prompt": "You are given a word. Your task is to find the closest vowel that stands between two consonants from the right side of the word (case sensitive). Vowels in the beginning and ending don't count. Return empty string if you didn't find any vowel that meets the above condition. You may assume that the given string contains English letters only.\n\nExamples:\n- get_closest_vowel(\"yogurt\") should return \"u\"\n- get_closest_vowel(\"FULL\") should return \"U\"  \n- get_closest_vowel(\"quick\") should return \"\"\n- get_closest_vowel(\"ab\") should return \"\"\n\nfunction get_closest_vowel(word string) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testGetClosestVowel() {\n    test:assertEquals(get_closest_vowel(\"yogurt\"), \"u\");\n    test:assertEquals(get_closest_vowel(\"full\"), \"u\");\n    test:assertEquals(get_closest_vowel(\"easy\"), \"\");\n    test:assertEquals(get_closest_vowel(\"eAsy\"), \"\");\n    test:assertEquals(get_closest_vowel(\"ali\"), \"\");\n    test:assertEquals(get_closest_vowel(\"bad\"), \"a\");\n    test:assertEquals(get_closest_vowel(\"most\"), \"o\");\n    test:assertEquals(get_closest_vowel(\"ab\"), \"\");\n    test:assertEquals(get_closest_vowel(\"ba\"), \"\");\n    test:assertEquals(get_closest_vowel(\"quick\"), \"\");\n    test:assertEquals(get_closest_vowel(\"anime\"), \"i\");\n    test:assertEquals(get_closest_vowel(\"Asia\"), \"\");\n    test:assertEquals(get_closest_vowel(\"Above\"), \"o\");\n}"
  },
  {
    "id": "request-116",
    "prompt": "You are given an array of two strings, both strings consist of open parentheses '(' or close parentheses ')' only. Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good.\n\nA string S is considered to be good if and only if all parentheses in S are balanced. For example: the string '(())()' is good, while the string '())' is not.\n\nReturn 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\nExamples:\n// match_parens([\"()(\", \")\"]) returns \"Yes\"\n// match_parens([\")\", \")\"]) returns \"No\"\n\nfunction match_parens(lst: string[]) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMatchParens1() {\n    test:assertEquals(match_parens([\"()(\", \")\"]), \"Yes\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens2() {\n    test:assertEquals(match_parens([\")\", \")\"]), \"No\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens3() {\n    test:assertEquals(match_parens([\"(()(())\", \"())())\"]), \"No\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens4() {\n    test:assertEquals(match_parens([\")())\", \"(()()(\"]); \"Yes\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens5() {\n    test:assertEquals(match_parens([\"(())))\", \"(()())((\"]); \"Yes\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens6() {\n    test:assertEquals(match_parens([\"()\", \"())\"]), \"No\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens7() {\n    test:assertEquals(match_parens([\"(()(\", \"()))()\"]); \"Yes\", msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens8() {\n    test:assertEquals(match_parens([\"((((\", \"((())\"]), \"No\", msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens9() {\n    test:assertEquals(match_parens([\")(()\", \"(()(\"]); \"No\", msg = \"Test case 9 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens10() {\n    test:assertEquals(match_parens([\")(\", \")(\"]), \"No\", msg = \"Test case 10 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens11() {\n    test:assertEquals(match_parens([\"(\", \")\"]), \"Yes\", msg = \"Test case 11 failed\");\n}\n\n@test:Config { }\nfunction testMatchParens12() {\n    test:assertEquals(match_parens([\")\", \"(\"]), \"Yes\", msg = \"Test case 12 failed\");\n}"
  },
  {
    "id": "request-117",
    "prompt": "Given an array of integers and a positive integer k, return a sorted array of length k containing the maximum k numbers from the original array.\n\nWrite a function with the signature:\n```ballerina\nfunction maximum(arr int[], k int) returns int[]\n```\n\nExamples:\n- maximum([-3, -4, 5], 3) should return [-4, -3, 5]\n- maximum([4, -4, 4], 2) should return [4, 4]  \n- maximum([-3, 2, 1, 2, -1, -2, 1], 1) should return [2]\n\nConstraints:\n- The length of the array will be in the range of [1, 1000]\n- The elements in the array will be in the range of [-1000, 1000]  \n- 0 <= k <= len(arr)",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMaximum1() {\n    int[] result = maximum([-3, -4, 5], 3);\n    test:assertEquals(result, [-4, -3, 5], msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testMaximum2() {\n    int[] result = maximum([4, -4, 4], 2);\n    test:assertEquals(result, [4, 4], msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testMaximum3() {\n    int[] result = maximum([-3, 2, 1, 2, -1, -2, 1], 1);\n    test:assertEquals(result, [2], msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testMaximum4() {\n    int[] result = maximum([123, -123, 20, 0, 1, 2, -3], 3);\n    test:assertEquals(result, [2, 20, 123], msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testMaximum5() {\n    int[] result = maximum([-123, 20, 0, 1, 2, -3], 4);\n    test:assertEquals(result, [0, 1, 2, 20], msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testMaximum6() {\n    int[] result = maximum([5, 15, 0, 3, -13, -8, 0], 7);\n    test:assertEquals(result, [-13, -8, 0, 0, 3, 5, 15], msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testMaximum7() {\n    int[] result = maximum([-1, 0, 2, 5, 3, -10], 2);\n    test:assertEquals(result, [3, 5], msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testMaximum8() {\n    int[] result = maximum([1, 0, 5, -7], 1);\n    test:assertEquals(result, [5], msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testMaximum9() {\n    int[] result = maximum([4, -4], 2);\n    test:assertEquals(result, [-4, 4], msg = \"Test case 9 failed\");\n}\n\n@test:Config { }\nfunction testMaximum10() {\n    int[] result = maximum([-10, 10], 2);\n    test:assertEquals(result, [-10, 10], msg = \"Test case 10 failed\");\n}\n\n@test:Config { }\nfunction testMaximum11() {\n    int[] result = maximum([1, 2, 3, -23, 243, -400, 0], 0);\n    test:assertEquals(result, [], msg = \"Test case 11 failed\");\n}"
  },
  {
    "id": "request-118",
    "prompt": "Given a non-empty array of integers, return the sum of all of the odd elements that are in even positions (indices 0, 2, 4, etc.).\n\nExamples:\n- solution([5, 8, 7, 1]) returns 12 (5 at index 0 + 7 at index 2 = 12)\n- solution([3, 3, 3, 3, 3]) returns 9 (3 at index 0 + 3 at index 2 + 3 at index 4 = 9)  \n- solution([30, 13, 24, 321]) returns 0 (no odd numbers at even positions)\n\nfunction solution(lst: int[]) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSolution1() {\n    int result = solution([5, 8, 7, 1]);\n    test:assertEquals(result, 12, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSolution2() {\n    int result = solution([3, 3, 3, 3, 3]);\n    test:assertEquals(result, 9, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSolution3() {\n    int result = solution([30, 13, 24, 321]);\n    test:assertEquals(result, 0, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSolution4() {\n    int result = solution([5, 9]);\n    test:assertEquals(result, 5, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testSolution5() {\n    int result = solution([2, 4, 8]);\n    test:assertEquals(result, 0, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testSolution6() {\n    int result = solution([30, 13, 23, 32]);\n    test:assertEquals(result, 23, msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testSolution7() {\n    int result = solution([3, 13, 2, 9]);\n    test:assertEquals(result, 3, msg = \"Test case 7 failed\");\n}"
  },
  {
    "id": "request-119",
    "prompt": "Given a non-empty array of integers and an integer k, return the sum of the elements with at most two digits from the first k elements of the array.\n\nFor example:\n- add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) should return 24\n\nConstraints:\n1. 1 <= len(arr) <= 100\n2. 1 <= k <= len(arr)\n\n```ballerina\nfunction add_elements(int[] arr, int k) returns int {\n    // Your implementation here\n}\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testAddElements1() {\n    int result = add_elements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3);\n    test:assertEquals(result, -4, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testAddElements2() {\n    int result = add_elements([111, 121, 3, 4000, 5, 6], 2);\n    test:assertEquals(result, 0, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testAddElements3() {\n    int result = add_elements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4);\n    test:assertEquals(result, 125, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testAddElements4() {\n    int result = add_elements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4);\n    test:assertEquals(result, 24, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testAddElements5() {\n    int result = add_elements([1], 1);\n    test:assertEquals(result, 1, msg = \"Test case 5 failed\");\n}"
  },
  {
    "id": "request-120",
    "prompt": "Given a positive integer n, return a sorted array that has the odd numbers in collatz sequence.\n\nThe Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows: start with any positive integer n. Then each term is obtained from the previous term as follows: if the previous term is even, the next term is one half of the previous term. If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\nNote: \n1. Collatz(1) is [1].\n2. returned array sorted in increasing order.\n\nFor example:\nget_odd_collatz(5) returns [1, 5] // The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n\n// get_odd_collatz(5)\n// [1, 5]\n\nfunction get_odd_collatz(int n) returns int[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGetOddCollatz1() {\n    int[] result = get_odd_collatz(14);\n    int[] expected = [1, 5, 7, 11, 13, 17];\n    test:assertEquals(result, expected, msg = \"Test case for n=14 failed\");\n}\n\n@test:Config { }\nfunction testGetOddCollatz2() {\n    int[] result = get_odd_collatz(5);\n    int[] expected = [1, 5];\n    test:assertEquals(result, expected, msg = \"Test case for n=5 failed\");\n}\n\n@test:Config { }\nfunction testGetOddCollatz3() {\n    int[] result = get_odd_collatz(12);\n    int[] expected = [1, 3, 5];\n    test:assertEquals(result, expected, msg = \"Test case for n=12 failed\");\n}\n\n@test:Config { }\nfunction testGetOddCollatz4() {\n    int[] result = get_odd_collatz(1);\n    int[] expected = [1];\n    test:assertEquals(result, expected, msg = \"Test case for n=1 failed\");\n}"
  },
  {
    "id": "request-121",
    "prompt": "Write a function that validates a given date string and returns true if the date is valid, otherwise false.\n\nThe date is valid if all of the following rules are satisfied:\n1. The date string is not empty.\n2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n3. The months should not be less than 1 or higher than 12.\n4. The date should be in the format: mm-dd-yyyy\n\nfunction valid_date(date: string) returns boolean {\n    // Implementation goes here\n}\n\n// valid_date(\"03-11-2000\") // true\n// valid_date(\"15-01-2012\") // false\n// valid_date(\"04-0-2040\") // false\n// valid_date(\"06-04-2020\") // true\n// valid_date(\"06/04/2020\") // false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testValidDate1() {\n    test:assertTrue(valid_date(\"03-11-2000\"), msg = \"03-11-2000 should be valid\");\n}\n\n@test:Config { }\nfunction testValidDate2() {\n    test:assertFalse(valid_date(\"15-01-2012\"), msg = \"15-01-2012 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate3() {\n    test:assertFalse(valid_date(\"04-0-2040\"), msg = \"04-0-2040 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate4() {\n    test:assertTrue(valid_date(\"06-04-2020\"), msg = \"06-04-2020 should be valid\");\n}\n\n@test:Config { }\nfunction testValidDate5() {\n    test:assertTrue(valid_date(\"01-01-2007\"), msg = \"01-01-2007 should be valid\");\n}\n\n@test:Config { }\nfunction testValidDate6() {\n    test:assertFalse(valid_date(\"03-32-2011\"), msg = \"03-32-2011 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate7() {\n    test:assertFalse(valid_date(\"\"), msg = \"Empty string should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate8() {\n    test:assertFalse(valid_date(\"04-31-3000\"), msg = \"04-31-3000 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate9() {\n    test:assertTrue(valid_date(\"06-06-2005\"), msg = \"06-06-2005 should be valid\");\n}\n\n@test:Config { }\nfunction testValidDate10() {\n    test:assertFalse(valid_date(\"21-31-2000\"), msg = \"21-31-2000 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate11() {\n    test:assertTrue(valid_date(\"04-12-2003\"), msg = \"04-12-2003 should be valid\");\n}\n\n@test:Config { }\nfunction testValidDate12() {\n    test:assertFalse(valid_date(\"04122003\"), msg = \"04122003 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate13() {\n    test:assertFalse(valid_date(\"20030412\"), msg = \"20030412 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate14() {\n    test:assertFalse(valid_date(\"2003-04\"), msg = \"2003-04 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate15() {\n    test:assertFalse(valid_date(\"2003-04-12\"), msg = \"2003-04-12 should be invalid\");\n}\n\n@test:Config { }\nfunction testValidDate16() {\n    test:assertFalse(valid_date(\"04-2003\"), msg = \"04-2003 should be invalid\");\n}"
  },
  {
    "id": "request-122",
    "prompt": "Given a string of words, return an array of words split on whitespace. If no whitespaces exist in the text, you should split on commas ','. If no commas exist, you should return the number of lower-case letters with odd order in the alphabet, where ord('a') = 0, ord('b') = 1, ... ord('z') = 25.\n\nWrite a function with this signature:\n```ballerina\nfunction split_words(txt string) returns string[]|int\n```\n\nExamples:\n// split_words(\"Hello world!\") should return [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") should return [\"Hello\", \"world!\"] \n// split_words(\"abcdef\") should return 3",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSplitWordsWithWhitespace() {\n    string[]|int result = split_words(\"Hello world!\");\n    test:assertEquals(result, [\"Hello\", \"world!\"], msg = \"Failed to split on whitespace\");\n}\n\n@test:Config { }\nfunction testSplitWordsWithComma() {\n    string[]|int result = split_words(\"Hello,world!\");\n    test:assertEquals(result, [\"Hello\", \"world!\"], msg = \"Failed to split on comma\");\n}\n\n@test:Config { }\nfunction testSplitWordsWithWhitespaceAndComma() {\n    string[]|int result = split_words(\"Hello world,!\");\n    test:assertEquals(result, [\"Hello\", \"world,!\"], msg = \"Failed to prioritize whitespace over comma\");\n}\n\n@test:Config { }\nfunction testSplitWordsMultipleDelimiters() {\n    string[]|int result = split_words(\"Hello,Hello,world !\");\n    test:assertEquals(result, [\"Hello,Hello,world\", \"!\"], msg = \"Failed to split complex string with whitespace\");\n}\n\n@test:Config { }\nfunction testCountOddPositionLetters1() {\n    string[]|int result = split_words(\"abcdef\");\n    test:assertEquals(result, 3, msg = \"Failed to count odd position lowercase letters\");\n}\n\n@test:Config { }\nfunction testCountOddPositionLetters2() {\n    string[]|int result = split_words(\"aaabb\");\n    test:assertEquals(result, 2, msg = \"Failed to count odd position lowercase letters\");\n}\n\n@test:Config { }\nfunction testCountOddPositionLetters3() {\n    string[]|int result = split_words(\"aaaBb\");\n    test:assertEquals(result, 1, msg = \"Failed to count odd position lowercase letters with mixed case\");\n}\n\n@test:Config { }\nfunction testEmptyString() {\n    string[]|int result = split_words(\"\");\n    test:assertEquals(result, 0, msg = \"Failed to handle empty string\");\n}"
  },
  {
    "id": "request-123",
    "prompt": "Given an array of numbers, determine whether they are sorted in ascending order. If any number appears more than twice in the array, return false. Assume the array contains only non-negative integers.\n\nExamples:\n// is_sorted([5]) should return true\n// is_sorted([1, 2, 3, 4, 5]) should return true  \n// is_sorted([1, 3, 2, 4, 5]) should return false\n// is_sorted([1, 2, 3, 4, 5, 6]) should return true\n// is_sorted([1, 2, 3, 4, 5, 6, 7]) should return true\n// is_sorted([1, 3, 2, 4, 5, 6, 7]) should return false\n// is_sorted([1, 2, 2, 3, 3, 4]) should return true\n// is_sorted([1, 2, 2, 2, 3, 4]) should return false\n\nWrite a function with this signature:\nfunction is_sorted(lst: int[]) returns boolean",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsSorted() {\n    test:assertEquals(is_sorted([5]), true);\n    test:assertEquals(is_sorted([1, 2, 3, 4, 5]), true);\n    test:assertEquals(is_sorted([1, 3, 2, 4, 5]), false);\n    test:assertEquals(is_sorted([1, 2, 3, 4, 5, 6]), true);\n    test:assertEquals(is_sorted([1, 2, 3, 4, 5, 6, 7]), true);\n    test:assertEquals(is_sorted([1, 3, 2, 4, 5, 6, 7]), false);\n    test:assertEquals(is_sorted([]), true);\n    test:assertEquals(is_sorted([1]), true);\n    test:assertEquals(is_sorted([3, 2, 1]), false);\n    test:assertEquals(is_sorted([1, 2, 2, 2, 3, 4]), false);\n    test:assertEquals(is_sorted([1, 2, 3, 3, 3, 4]), false);\n    test:assertEquals(is_sorted([1, 2, 2, 3, 3, 4]), true);\n    test:assertEquals(is_sorted([1, 2, 3, 4]), true);\n}"
  },
  {
    "id": "request-124",
    "prompt": "You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end.\n\nYour task is to determine whether the length of intersection of these two intervals is a prime number. For example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which is not a prime number.\n\nIf the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".\n\nWrite a function with the following signature:\n```ballerina\nfunction intersection(interval1: [int, int], interval2: [int, int]) returns string\n```\n\nExpected function calls:\n```ballerina\nintersection([1, 2], [2, 3]) // \"NO\"\nintersection([-1, 1], [0, 4]) // \"NO\"  \nintersection([-3, -1], [-5, 5]) // \"YES\"\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIntersection1() {\n    string result = intersection([1, 2], [2, 3]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testIntersection2() {\n    string result = intersection([-1, 1], [0, 4]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testIntersection3() {\n    string result = intersection([-3, -1], [-5, 5]);\n    test:assertEquals(result, \"YES\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testIntersection4() {\n    string result = intersection([-2, 2], [-4, 0]);\n    test:assertEquals(result, \"YES\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testIntersection5() {\n    string result = intersection([-11, 2], [-1, -1]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testIntersection6() {\n    string result = intersection([1, 2], [3, 5]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testIntersection7() {\n    string result = intersection([1, 2], [1, 2]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testIntersection8() {\n    string result = intersection([-2, -2], [-3, -2]);\n    test:assertEquals(result, \"NO\", msg = \"Test case 8 failed\");\n}"
  },
  {
    "id": "request-125",
    "prompt": "You are given an array of integers and you need to return the sum of magnitudes (absolute values) of integers multiplied by the product of all signs of each number in the array, represented by 1, -1 or 0. Return nil for empty arrays.\n\nExamples:\n// prod_signs([1, 2, 2, -4]) returns -9\n// prod_signs([0, 1]) returns 0  \n// prod_signs([]) returns nil\n\nfunction prod_signs(arr int[]) returns int? {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testProdSigns1() {\n    int? result = prod_signs([1, 2, 2, -4]);\n    test:assertEquals(result, -9, msg = \"Failed for [1, 2, 2, -4]\");\n}\n\n@test:Config { }\nfunction testProdSigns2() {\n    int? result = prod_signs([0, 1]);\n    test:assertEquals(result, 0, msg = \"Failed for [0, 1]\");\n}\n\n@test:Config { }\nfunction testProdSigns3() {\n    int? result = prod_signs([1, 1, 1, 2, 3, -1, 1]);\n    test:assertEquals(result, -10, msg = \"Failed for [1, 1, 1, 2, 3, -1, 1]\");\n}\n\n@test:Config { }\nfunction testProdSigns4() {\n    int? result = prod_signs([]);\n    test:assertEquals(result, (), msg = \"Failed for empty array\");\n}\n\n@test:Config { }\nfunction testProdSigns5() {\n    int? result = prod_signs([2, 4, 1, 2, -1, -1, 9]);\n    test:assertEquals(result, 20, msg = \"Failed for [2, 4, 1, 2, -1, -1, 9]\");\n}\n\n@test:Config { }\nfunction testProdSigns6() {\n    int? result = prod_signs([-1, 1, -1, 1]);\n    test:assertEquals(result, 4, msg = \"Failed for [-1, 1, -1, 1]\");\n}\n\n@test:Config { }\nfunction testProdSigns7() {\n    int? result = prod_signs([-1, 1, 1, 1]);\n    test:assertEquals(result, -4, msg = \"Failed for [-1, 1, 1, 1]\");\n}\n\n@test:Config { }\nfunction testProdSigns8() {\n    int? result = prod_signs([-1, 1, 1, 0]);\n    test:assertEquals(result, 0, msg = \"Failed for [-1, 1, 1, 0]\");\n}"
  },
  {
    "id": "request-126",
    "prompt": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, each cell of the grid contains a value. Every integer in the range [1, N * N] inclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start from any cell, and in each step you can move to any of the neighbor cells, in other words, you can go to cells which share an edge with your current cell.\n\nPlease note that a path of length k means visiting exactly k cells (not necessarily distinct). You CANNOT go off the grid.\n\nA path A (of length k) is considered less than a path B (of length k) if after making the ordered arrays of the values on the cells that A and B go through (let's call them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other words, there exist an integer index i (1 <= i <= k) such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have lst_A[j] = lst_B[j].\n\nIt is guaranteed that the answer is unique. Return an ordered array of the values on the cells that the minimum path go through.\n\nfunction minPath(grid: int[][], k: int) returns int[] {\n    // Your implementation here\n}\n\n// minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) → [1, 2, 1]\n// minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) → [1]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testMinPath() {\n    test:assertEquals(minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3), [1, 2, 1]);\n    test:assertEquals(minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1), [1]);\n    test:assertEquals(minPath([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4), [1, 2, 1, 2]);\n    test:assertEquals(minPath([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7), [1, 10, 1, 10, 1, 10, 1]);\n    test:assertEquals(minPath([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5), [1, 7, 1, 7, 1]);\n    test:assertEquals(minPath([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9), [1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    test:assertEquals(minPath([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12), [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    test:assertEquals(minPath([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8), [1, 3, 1, 3, 1, 3, 1, 3]);\n    test:assertEquals(minPath([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8), [1, 5, 1, 5, 1, 5, 1, 5]);\n    test:assertEquals(minPath([[1, 2], [3, 4]], 10), [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    test:assertEquals(minPath([[1, 3], [3, 2]], 10), [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}"
  },
  {
    "id": "request-127",
    "prompt": "You need to implement the Tribonacci sequence which is defined by these rules:\n- tri(1) = 3\n- tri(n) = 1 + n / 2, if n is even\n- tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd\n\nFor example:\n- tri(2) = 1 + (2 / 2) = 2\n- tri(4) = 3  \n- tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8\n\nGiven a non-negative integer n, return an array of the first n + 1 numbers of the Tribonacci sequence.\n\n```ballerina\nfunction tri(n int) returns int[] {\n    // Your implementation here\n}\n```\n\nExpected function calls:\n// tri(3) → [1, 3, 2, 8]\n// tri(4) → [1, 3, 2, 8, 3]  \n// tri(0) → [1]\n// tri(1) → [1, 3]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testTri() {\n    test:assertEquals(tri(3), [1, 3, 2, 8], msg = \"tri(3) failed\");\n    test:assertEquals(tri(4), [1, 3, 2, 8, 3], msg = \"tri(4) failed\");\n    test:assertEquals(tri(5), [1, 3, 2, 8, 3, 15], msg = \"tri(5) failed\");\n    test:assertEquals(tri(6), [1, 3, 2, 8, 3, 15, 4], msg = \"tri(6) failed\");\n    test:assertEquals(tri(7), [1, 3, 2, 8, 3, 15, 4, 24], msg = \"tri(7) failed\");\n    test:assertEquals(tri(8), [1, 3, 2, 8, 3, 15, 4, 24, 5], msg = \"tri(8) failed\");\n    test:assertEquals(tri(9), [1, 3, 2, 8, 3, 15, 4, 24, 5, 35], msg = \"tri(9) failed\");\n    test:assertEquals(tri(20), [1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11], msg = \"tri(20) failed\");\n    test:assertEquals(tri(0), [1], msg = \"tri(0) failed\");\n    test:assertEquals(tri(1), [1, 3], msg = \"tri(1) failed\");\n}"
  },
  {
    "id": "request-128",
    "prompt": "Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even.\n\nFor example:\n- digits(1) should return 1\n- digits(4) should return 0  \n- digits(235) should return 15\n\nWrite a function with the signature:\n```ballerina\nfunction digits(n int) returns int\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testDigits5() {\n    int result = digits(5);\n    test:assertEquals(result, 5, msg = \"digits(5) should return 5\");\n}\n\n@test:Config { }\nfunction testDigits54() {\n    int result = digits(54);\n    test:assertEquals(result, 5, msg = \"digits(54) should return 5\");\n}\n\n@test:Config { }\nfunction testDigits120() {\n    int result = digits(120);\n    test:assertEquals(result, 1, msg = \"digits(120) should return 1\");\n}\n\n@test:Config { }\nfunction testDigits5014() {\n    int result = digits(5014);\n    test:assertEquals(result, 5, msg = \"digits(5014) should return 5\");\n}\n\n@test:Config { }\nfunction testDigits98765() {\n    int result = digits(98765);\n    test:assertEquals(result, 315, msg = \"digits(98765) should return 315\");\n}\n\n@test:Config { }\nfunction testDigits5576543() {\n    int result = digits(5576543);\n    test:assertEquals(result, 2625, msg = \"digits(5576543) should return 2625\");\n}\n\n@test:Config { }\nfunction testDigits2468() {\n    int result = digits(2468);\n    test:assertEquals(result, 0, msg = \"digits(2468) should return 0\");\n}"
  },
  {
    "id": "request-129",
    "prompt": "Create a function that takes a string as input which contains only square brackets. The function should return true if and only if there is a valid subsequence of brackets where at least one bracket in the subsequence is nested.\n\n```ballerina\nfunction is_nested(string str) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- is_nested(\"[[]]\") returns true (nested brackets exist)\n- is_nested(\"[]]]]]]][[[[[]\") returns false (no valid nested sequence)\n- is_nested(\"[][]\") returns false (adjacent but not nested)\n- is_nested(\"[]\") returns false (single pair, not nested)\n- is_nested(\"[[][]]\") returns true (contains nested brackets)\n- is_nested(\"[[]][[\") returns true (has nested brackets in valid subsequence)",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testIsNested1() {\n    test:assertTrue(is_nested(\"[[]]\"), msg = \"Failed for [[]]\");\n}\n\n@test:Config {}\nfunction testIsNested2() {\n    test:assertFalse(is_nested(\"[]]]]]]][[[[[]\"), msg = \"Failed for []]]]]]][[[[[]\");\n}\n\n@test:Config {}\nfunction testIsNested3() {\n    test:assertFalse(is_nested(\"[][]\"), msg = \"Failed for [][]\");\n}\n\n@test:Config {}\nfunction testIsNested4() {\n    test:assertFalse(is_nested(\"[]\"), msg = \"Failed for []\");\n}\n\n@test:Config {}\nfunction testIsNested5() {\n    test:assertTrue(is_nested(\"[[[[]]]]\"), msg = \"Failed for [[[[]]]]\");\n}\n\n@test:Config {}\nfunction testIsNested6() {\n    test:assertFalse(is_nested(\"[]]]]]]]]]]\"), msg = \"Failed for []]]]]]]]]]\");\n}\n\n@test:Config {}\nfunction testIsNested7() {\n    test:assertTrue(is_nested(\"[][][[]]\"), msg = \"Failed for [][][[]]\");\n}\n\n@test:Config {}\nfunction testIsNested8() {\n    test:assertFalse(is_nested(\"[[]\"), msg = \"Failed for [[]\");\n}\n\n@test:Config {}\nfunction testIsNested9() {\n    test:assertFalse(is_nested(\"[]]\"), msg = \"Failed for []]\");\n}\n\n@test:Config {}\nfunction testIsNested10() {\n    test:assertTrue(is_nested(\"[[]][[\"), msg = \"Failed for [[]][[ \");\n}\n\n@test:Config {}\nfunction testIsNested11() {\n    test:assertTrue(is_nested(\"[[][]]\"), msg = \"Failed for [[][]]\");\n}\n\n@test:Config {}\nfunction testIsNested12() {\n    test:assertFalse(is_nested(\"\"), msg = \"Failed for empty string\");\n}\n\n@test:Config {}\nfunction testIsNested13() {\n    test:assertFalse(is_nested(\"[[[[[[[[\"), msg = \"Failed for [[[[[[[[\");\n}\n\n@test:Config {}\nfunction testIsNested14() {\n    test:assertFalse(is_nested(\"]]]]]]]]\"), msg = \"Failed for ]]]]]]]]\");\n}"
  },
  {
    "id": "request-130",
    "prompt": "You are given an array of decimal numbers. You need to return the sum of squared numbers in the given array, but first round each element in the array to the upper integer (ceiling).\n\nWrite a function `sum_squares` that takes an array of float values and returns an integer.\n\nExamples:\n// sum_squares([1.0, 2.0, 3.0]) should return 14\n// sum_squares([1.0, 4.0, 9.0]) should return 98  \n// sum_squares([1.0, 3.0, 5.0, 7.0]) should return 84\n// sum_squares([1.4, 4.2, 0.0]) should return 29\n// sum_squares([-2.4, 1.0, 1.0]) should return 6\n\nfunction sum_squares(lst: float[]) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSumSquares1() {\n    int result = sum_squares([1.0, 2.0, 3.0]);\n    test:assertEquals(result, 14, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares2() {\n    int result = sum_squares([1.0, 3.0, 5.0, 7.0]);\n    test:assertEquals(result, 84, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares3() {\n    int result = sum_squares([1.4, 4.2, 0.0]);\n    test:assertEquals(result, 29, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares4() {\n    int result = sum_squares([-2.4, 1.0, 1.0]);\n    test:assertEquals(result, 6, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares5() {\n    int result = sum_squares([100.0, 1.0, 15.0, 2.0]);\n    test:assertEquals(result, 10230, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares6() {\n    int result = sum_squares([10000.0, 10000.0]);\n    test:assertEquals(result, 200000000, msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares7() {\n    int result = sum_squares([-1.4, 4.6, 6.3]);\n    test:assertEquals(result, 75, msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares8() {\n    int result = sum_squares([-1.4, 17.9, 18.9, 19.9]);\n    test:assertEquals(result, 1086, msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares9() {\n    int result = sum_squares([0.0]);\n    test:assertEquals(result, 0, msg = \"Test case 9 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares10() {\n    int result = sum_squares([-1.0]);\n    test:assertEquals(result, 1, msg = \"Test case 10 failed\");\n}\n\n@test:Config { }\nfunction testSumSquares11() {\n    int result = sum_squares([-1.0, 1.0, 0.0]);\n    test:assertEquals(result, 2, msg = \"Test case 11 failed\");\n}"
  },
  {
    "id": "request-131",
    "prompt": "Create a function that returns true if the last character of a given string is an alphabetical character and is not part of a word, and false otherwise. A \"word\" is a group of characters separated by space.\n\n```ballerina\nfunction check_if_last_char_is_a_letter(txt: string) returns boolean {\n    // Your implementation here\n}\n```\n\nExamples:\n- check_if_last_char_is_a_letter(\"apple pie\") should return false\n- check_if_last_char_is_a_letter(\"apple pi e\") should return true  \n- check_if_last_char_is_a_letter(\"apple pi e \") should return false\n- check_if_last_char_is_a_letter(\"\") should return false",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCheckIfLastCharIsALetter() {\n    test:assertFalse(check_if_last_char_is_a_letter(\"apple\"), msg = \"Failed for 'apple'\");\n    test:assertTrue(check_if_last_char_is_a_letter(\"apple pi e\"), msg = \"Failed for 'apple pi e'\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"eeeee\"), msg = \"Failed for 'eeeee'\");\n    test:assertTrue(check_if_last_char_is_a_letter(\"A\"), msg = \"Failed for 'A'\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"Pumpkin pie \"), msg = \"Failed for 'Pumpkin pie '\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"Pumpkin pie 1\"), msg = \"Failed for 'Pumpkin pie 1'\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"\"), msg = \"Failed for empty string\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"eeeee e \"), msg = \"Failed for 'eeeee e '\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"apple pie\"), msg = \"Failed for 'apple pie'\");\n    test:assertFalse(check_if_last_char_is_a_letter(\"apple pi e \"), msg = \"Failed for 'apple pi e '\");\n}"
  },
  {
    "id": "request-132",
    "prompt": "Create a function that returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1. The given array will not contain duplicate values.\n\nExamples:\n// can_arrange([1, 2, 4, 3, 5]) returns 3 (because 3 < 4)\n// can_arrange([1, 2, 3]) returns -1 (no element is smaller than its predecessor)\n\nfunction can_arrange(arr int[]) returns int {\n    // Implementation goes here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCanArrange1() {\n    int result = can_arrange([1, 2, 4, 3, 5]);\n    test:assertEquals(result, 3, msg = \"Should return 3 for [1, 2, 4, 3, 5]\");\n}\n\n@test:Config { }\nfunction testCanArrange2() {\n    int result = can_arrange([1, 2, 4, 5]);\n    test:assertEquals(result, -1, msg = \"Should return -1 for [1, 2, 4, 5]\");\n}\n\n@test:Config { }\nfunction testCanArrange3() {\n    int result = can_arrange([1, 4, 2, 5, 6, 7, 8, 9, 10]);\n    test:assertEquals(result, 2, msg = \"Should return 2 for [1, 4, 2, 5, 6, 7, 8, 9, 10]\");\n}\n\n@test:Config { }\nfunction testCanArrange4() {\n    int result = can_arrange([4, 8, 5, 7, 3]);\n    test:assertEquals(result, 4, msg = \"Should return 4 for [4, 8, 5, 7, 3]\");\n}\n\n@test:Config { }\nfunction testCanArrange5() {\n    int result = can_arrange([]);\n    test:assertEquals(result, -1, msg = \"Should return -1 for empty array\");\n}"
  },
  {
    "id": "request-133",
    "prompt": "Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in an array. If there is no negative or positive integers, return them as nil.\n\nfunction largest_smallest_integers(lst: int[]) returns [int?, int?] {\n    // Your implementation here\n}\n\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) should return [(), 1]\n// largest_smallest_integers([]) should return [(), ()]  \n// largest_smallest_integers([0]) should return [(), ()]",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testLargestSmallestIntegers() {\n    test:assertEquals(largest_smallest_integers([2, 4, 1, 3, 5, 7]), [(), 1], msg = \"Failed for positive only array\");\n    test:assertEquals(largest_smallest_integers([2, 4, 1, 3, 5, 7, 0]), [(), 1], msg = \"Failed for positive with zero array\");\n    test:assertEquals(largest_smallest_integers([1, 3, 2, 4, 5, 6, -2]), [-2, 1], msg = \"Failed for mixed array\");\n    test:assertEquals(largest_smallest_integers([4, 5, 3, 6, 2, 7, -7]), [-7, 2], msg = \"Failed for mixed array with -7\");\n    test:assertEquals(largest_smallest_integers([7, 3, 8, 4, 9, 2, 5, -9]), [-9, 2], msg = \"Failed for mixed array with -9\");\n    test:assertEquals(largest_smallest_integers([]), [(), ()], msg = \"Failed for empty array\");\n    test:assertEquals(largest_smallest_integers([0]), [(), ()], msg = \"Failed for array with only zero\");\n    test:assertEquals(largest_smallest_integers([-1, -3, -5, -6]), [-1, ()], msg = \"Failed for negative only array\");\n    test:assertEquals(largest_smallest_integers([-1, -3, -5, -6, 0]), [-1, ()], msg = \"Failed for negative with zero array\");\n    test:assertEquals(largest_smallest_integers([-6, -4, -4, -3, 1]), [-3, 1], msg = \"Failed for mixed array with duplicates\");\n    test:assertEquals(largest_smallest_integers([-6, -4, -4, -3, -100, 1]), [-3, 1], msg = \"Failed for mixed array with -100\");\n}"
  },
  {
    "id": "request-134",
    "prompt": "// Write a function that evaluates whether the given number n can be written as the sum of exactly 4 positive even numbers.\n// The smallest positive even number is 2, so the minimum sum of 4 positive even numbers is 8.\n// \n// is_equal_to_sum_even(4) // false\n// is_equal_to_sum_even(6) // false  \n// is_equal_to_sum_even(8) // true\n// is_equal_to_sum_even(10) // true\nfunction is_equal_to_sum_even(n int) returns boolean {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIsEqualToSumEven() {\n    test:assertFalse(is_equal_to_sum_even(4), msg = \"4 should return false\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven2() {\n    test:assertFalse(is_equal_to_sum_even(6), msg = \"6 should return false\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven3() {\n    test:assertTrue(is_equal_to_sum_even(8), msg = \"8 should return true\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven4() {\n    test:assertTrue(is_equal_to_sum_even(10), msg = \"10 should return true\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven5() {\n    test:assertFalse(is_equal_to_sum_even(11), msg = \"11 should return false\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven6() {\n    test:assertTrue(is_equal_to_sum_even(12), msg = \"12 should return true\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven7() {\n    test:assertFalse(is_equal_to_sum_even(13), msg = \"13 should return false\");\n}\n\n@test:Config { }\nfunction testIsEqualToSumEven8() {\n    test:assertTrue(is_equal_to_sum_even(16), msg = \"16 should return true\");\n}"
  },
  {
    "id": "request-135",
    "prompt": "// The Brazilian factorial is defined as:\n// brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n// where n > 0\n// For example:\n// special_factorial(4) should return 288\n// The function will receive an integer as input and should return the special\n// factorial of this integer.\n\nfunction special_factorial(int n) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSpecialFactorial4() {\n    int result = special_factorial(4);\n    test:assertEquals(result, 288, msg = \"special_factorial(4) should return 288\");\n}\n\n@test:Config { }\nfunction testSpecialFactorial5() {\n    int result = special_factorial(5);\n    test:assertEquals(result, 34560, msg = \"special_factorial(5) should return 34560\");\n}\n\n@test:Config { }\nfunction testSpecialFactorial7() {\n    int result = special_factorial(7);\n    test:assertEquals(result, 125411328000, msg = \"special_factorial(7) should return 125411328000\");\n}\n\n@test:Config { }\nfunction testSpecialFactorial1() {\n    int result = special_factorial(1);\n    test:assertEquals(result, 1, msg = \"special_factorial(1) should return 1\");\n}"
  },
  {
    "id": "request-136",
    "prompt": "Given a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, then replace all consecutive spaces with a single dash.\n\nWrite a function `fix_spaces` that takes a string parameter and returns the modified string according to these rules:\n- Single spaces should be replaced with underscores (_)\n- Two consecutive spaces should be replaced with two underscores (__)\n- More than 2 consecutive spaces should be replaced with a single dash (-)\n\nfunction fix_spaces(text string) returns string {\n    // Your implementation here\n}\n\n// Expected outputs:\n// fix_spaces(\"Example\") -> \"Example\"\n// fix_spaces(\" Example\") -> \"_Example\"  \n// fix_spaces(\" Example 1\") -> \"_Example_1\"\n// fix_spaces(\" Example 2\") -> \"__Example_2\"\n// fix_spaces(\" Example 3\") -> \"-Example_3\"",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFixSpaces() {\n    test:assertEquals(fix_spaces(\"Example\"), \"Example\", msg = \"Single word without spaces failed\");\n}\n\n@test:Config { }\nfunction testFixSpacesWithTrailingSpace() {\n    test:assertEquals(fix_spaces(\"Mudasir Hanif \"), \"Mudasir_Hanif_\", msg = \"String with trailing space failed\");\n}\n\n@test:Config { }\nfunction testFixSpacesWithDoubleSpaces() {\n    test:assertEquals(fix_spaces(\"Yellow Yellow  Dirty  Fellow\"), \"Yellow_Yellow__Dirty__Fellow\", msg = \"String with double spaces failed\");\n}\n\n@test:Config { }\nfunction testFixSpacesWithTripleSpaces() {\n    test:assertEquals(fix_spaces(\"Exa   mple\"), \"Exa-mple\", msg = \"String with triple spaces failed\");\n}\n\n@test:Config { }\nfunction testFixSpacesWithLeadingSpaces() {\n    test:assertEquals(fix_spaces(\"   Exa 1 2 2 mple\"), \"-Exa_1_2_2_mple\", msg = \"String with leading multiple spaces failed\");\n}"
  },
  {
    "id": "request-137",
    "prompt": "Create a function that takes a string representing a file's name and returns 'Yes' if the file's name is valid, and returns 'No' otherwise.\n\nA file's name is considered to be valid if and only if all the following conditions are met:\n- There should not be more than three digits ('0'-'9') in the file's name.\n- The file's name contains exactly one dot '.'\n- The substring before the dot should not be empty, and it starts with a letter from the latin alphabet ('a'-'z' and 'A'-'Z').\n- The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\nExamples:\n// file_name_check(\"example.txt\") // \"Yes\"\n// file_name_check(\"1example.dll\") // \"No\"\n\nfunction file_name_check(file_name string) returns string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFileNameCheck() {\n    test:assertEquals(file_name_check(\"example.txt\"), \"Yes\", msg = \"example.txt should be valid\");\n    test:assertEquals(file_name_check(\"1example.dll\"), \"No\", msg = \"1example.dll should be invalid\");\n    test:assertEquals(file_name_check(\"s1sdf3.asd\"), \"No\", msg = \"s1sdf3.asd should be invalid\");\n    test:assertEquals(file_name_check(\"K.dll\"), \"Yes\", msg = \"K.dll should be valid\");\n    test:assertEquals(file_name_check(\"MY16FILE3.exe\"), \"Yes\", msg = \"MY16FILE3.exe should be valid\");\n    test:assertEquals(file_name_check(\"His12FILE94.exe\"), \"No\", msg = \"His12FILE94.exe should be invalid\");\n    test:assertEquals(file_name_check(\"_Y.txt\"), \"No\", msg = \"_Y.txt should be invalid\");\n    test:assertEquals(file_name_check(\"?aREYA.exe\"), \"No\", msg = \"?aREYA.exe should be invalid\");\n    test:assertEquals(file_name_check(\"/this_is_valid.dll\"), \"No\", msg = \"/this_is_valid.dll should be invalid\");\n    test:assertEquals(file_name_check(\"this_is_valid.wow\"), \"No\", msg = \"this_is_valid.wow should be invalid\");\n    test:assertEquals(file_name_check(\"this_is_valid.txt\"), \"Yes\", msg = \"this_is_valid.txt should be valid\");\n    test:assertEquals(file_name_check(\"this_is_valid.txtexe\"), \"No\", msg = \"this_is_valid.txtexe should be invalid\");\n    test:assertEquals(file_name_check(\"#this2_i4s_5valid.ten\"), \"No\", msg = \"#this2_i4s_5valid.ten should be invalid\");\n    test:assertEquals(file_name_check(\"@this1_is6_valid.exe\"), \"No\", msg = \"@this1_is6_valid.exe should be invalid\");\n    test:assertEquals(file_name_check(\"this_is_12valid.6exe4.txt\"), \"No\", msg = \"this_is_12valid.6exe4.txt should be invalid\");\n    test:assertEquals(file_name_check(\"all.exe.txt\"), \"No\", msg = \"all.exe.txt should be invalid\");\n    test:assertEquals(file_name_check(\"I563_No.exe\"), \"Yes\", msg = \"I563_No.exe should be valid\");\n    test:assertEquals(file_name_check(\"Is3youfault.txt\"), \"Yes\", msg = \"Is3youfault.txt should be valid\");\n    test:assertEquals(file_name_check(\"no_one#knows.dll\"), \"Yes\", msg = \"no_one#knows.dll should be valid\");\n    test:assertEquals(file_name_check(\"1I563_Yes3.exe\"), \"No\", msg = \"1I563_Yes3.exe should be invalid\");\n    test:assertEquals(file_name_check(\"I563_Yes3.txtt\"), \"No\", msg = \"I563_Yes3.txtt should be invalid\");\n    test:assertEquals(file_name_check(\"final..txt\"), \"No\", msg = \"final..txt should be invalid\");\n    test:assertEquals(file_name_check(\"final132\"), \"No\", msg = \"final132 should be invalid\");\n    test:assertEquals(file_name_check(\"_f4indsartal132.\"), \"No\", msg = \"_f4indsartal132. should be invalid\");\n    test:assertEquals(file_name_check(\".txt\"), \"No\", msg = \".txt should be invalid\");\n    test:assertEquals(file_name_check(\"s.\"), \"No\", msg = \"s. should be invalid\");\n}"
  },
  {
    "id": "request-138",
    "prompt": "Write a function that takes an array of integers and processes each element based on its index position. For elements at indices that are multiples of 3, square the value. For elements at indices that are multiples of 4 but not multiples of 3, cube the value. Leave all other elements unchanged. Return the sum of all processed elements.\n\n```ballerina\nfunction sum_squares(lst int[]) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n- sum_squares([1, 2, 3]) returns 6\n- sum_squares([]) returns 0\n- sum_squares([-1, -5, 2, -1, -5]) returns -126",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSumSquares1() {\n    test:assertEquals(sum_squares([1, 2, 3]), 6);\n}\n\n@test:Config { }\nfunction testSumSquares2() {\n    test:assertEquals(sum_squares([1, 4, 9]), 14);\n}\n\n@test:Config { }\nfunction testSumSquares3() {\n    test:assertEquals(sum_squares([]), 0);\n}\n\n@test:Config { }\nfunction testSumSquares4() {\n    test:assertEquals(sum_squares([1, 1, 1, 1, 1, 1, 1, 1, 1]), 9);\n}\n\n@test:Config { }\nfunction testSumSquares5() {\n    test:assertEquals(sum_squares([-1, -1, -1, -1, -1, -1, -1, -1, -1]), -3);\n}\n\n@test:Config { }\nfunction testSumSquares6() {\n    test:assertEquals(sum_squares([0]), 0);\n}\n\n@test:Config { }\nfunction testSumSquares7() {\n    test:assertEquals(sum_squares([-1, -5, 2, -1, -5]), -126);\n}\n\n@test:Config { }\nfunction testSumSquares8() {\n    test:assertEquals(sum_squares([-56, -99, 1, 0, -2]), 3030);\n}\n\n@test:Config { }\nfunction testSumSquares9() {\n    test:assertEquals(sum_squares([-1, 0, 0, 0, 0, 0, 0, 0, -1]), 0);\n}\n\n@test:Config { }\nfunction testSumSquares10() {\n    test:assertEquals(sum_squares([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]), -14196);\n}\n\n@test:Config { }\nfunction testSumSquares11() {\n    test:assertEquals(sum_squares([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]), -1448);\n}"
  },
  {
    "id": "request-139",
    "prompt": "You are given a string representing a sentence. The sentence contains words separated by spaces, and you need to return a string containing only the words whose lengths are prime numbers. The order of words should remain the same as in the original sentence.\n\nExamples:\n- words_in_sentence(\"This is a test\") should return \"is\"\n- words_in_sentence(\"lets go for swimming\") should return \"go for\"\n\nConstraints:\n- 1 <= len(sentence) <= 100\n- sentence contains only letters and spaces\n\nfunction words_in_sentence(sentence: string): string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testWordsInSentence1() {\n    test:assertEquals(words_in_sentence(\"This is a test\"), \"is\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence2() {\n    test:assertEquals(words_in_sentence(\"lets go for swimming\"), \"go for\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence3() {\n    test:assertEquals(words_in_sentence(\"there is no place available here\"), \"there is no place\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence4() {\n    test:assertEquals(words_in_sentence(\"Hi I am Hussein\"), \"Hi am Hussein\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence5() {\n    test:assertEquals(words_in_sentence(\"go for it\"), \"go for it\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence6() {\n    test:assertEquals(words_in_sentence(\"here\"), \"\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testWordsInSentence7() {\n    test:assertEquals(words_in_sentence(\"here is\"), \"is\", msg = \"Test case 7 failed\");\n}"
  },
  {
    "id": "request-140",
    "prompt": "Implement a function that determines whether the product of two fractions x and n results in a whole number. Both x and n are string representations of fractions in the format \"numerator/denominator\" where both numerator and denominator are positive whole numbers. The function should return true if x * n evaluates to a whole number and false otherwise.\n\nYou can assume that x and n are valid fractions and do not have zero as denominator.\n\n```ballerina\nfunction simplify(string x, string n) returns boolean {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- simplify(\"1/5\", \"5/1\") should return true (1/5 * 5/1 = 1)\n- simplify(\"1/6\", \"2/1\") should return false (1/6 * 2/1 = 2/6 = 1/3)\n- simplify(\"7/10\", \"10/2\") should return false (7/10 * 10/2 = 7/2 = 3.5)",
    "test": "import ballerina/test;\n\n@test:Config {}\nfunction testSimplify1() {\n    test:assertTrue(simplify(\"1/5\", \"5/1\"), msg = \"Test case 1 failed\");\n}\n\n@test:Config {}\nfunction testSimplify2() {\n    test:assertFalse(simplify(\"1/6\", \"2/1\"), msg = \"Test case 2 failed\");\n}\n\n@test:Config {}\nfunction testSimplify3() {\n    test:assertTrue(simplify(\"5/1\", \"3/1\"), msg = \"Test case 3 failed\");\n}\n\n@test:Config {}\nfunction testSimplify4() {\n    test:assertFalse(simplify(\"7/10\", \"10/2\"), msg = \"Test case 4 failed\");\n}\n\n@test:Config {}\nfunction testSimplify5() {\n    test:assertTrue(simplify(\"2/10\", \"50/10\"), msg = \"Test case 5 failed\");\n}\n\n@test:Config {}\nfunction testSimplify6() {\n    test:assertTrue(simplify(\"7/2\", \"4/2\"), msg = \"Test case 6 failed\");\n}\n\n@test:Config {}\nfunction testSimplify7() {\n    test:assertTrue(simplify(\"11/6\", \"6/1\"), msg = \"Test case 7 failed\");\n}\n\n@test:Config {}\nfunction testSimplify8() {\n    test:assertFalse(simplify(\"2/3\", \"5/2\"), msg = \"Test case 8 failed\");\n}\n\n@test:Config {}\nfunction testSimplify9() {\n    test:assertFalse(simplify(\"5/2\", \"3/5\"), msg = \"Test case 9 failed\");\n}\n\n@test:Config {}\nfunction testSimplify10() {\n    test:assertTrue(simplify(\"2/4\", \"8/4\"), msg = \"Test case 10 failed\");\n}\n\n@test:Config {}\nfunction testSimplify11() {\n    test:assertTrue(simplify(\"2/4\", \"4/2\"), msg = \"Test case 11 failed\");\n}\n\n@test:Config {}\nfunction testSimplify12() {\n    test:assertTrue(simplify(\"1/5\", \"5/1\"), msg = \"Test case 12 failed\");\n}\n\n@test:Config {}\nfunction testSimplify13() {\n    test:assertFalse(simplify(\"1/5\", \"1/5\"), msg = \"Test case 13 failed\");\n}"
  },
  {
    "id": "request-141",
    "prompt": "Write a function that sorts an array of integers in ascending order based on the sum of their digits. If multiple numbers have the same digit sum, maintain their original order from the input array.\n\nFor example:\n- order_by_points([1, 11, -1, -11, -12]) should return [-1, -11, 1, -12, 11]\n- order_by_points([]) should return []\n\n```ballerina\nfunction order_by_points(nums int[]) returns int[] {\n    // Your implementation here\n}\n```\n\nThe function should:\n1. Calculate the sum of digits for each number (treating negative signs appropriately)\n2. Sort by digit sum in ascending order\n3. Preserve original order for numbers with equal digit sums",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testOrderByPointsBasic() {\n    int[] result = order_by_points([1, 11, -1, -11, -12]);\n    int[] expected = [-1, -11, 1, -12, 11];\n    test:assertEquals(result, expected, msg = \"Basic test case failed\");\n}\n\n@test:Config { }\nfunction testOrderByPointsComplex() {\n    int[] result = order_by_points([1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]);\n    int[] expected = [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457];\n    test:assertEquals(result, expected, msg = \"Complex test case failed\");\n}\n\n@test:Config { }\nfunction testOrderByPointsEmpty() {\n    int[] result = order_by_points([]);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Empty array test failed\");\n}\n\n@test:Config { }\nfunction testOrderByPointsNegatives() {\n    int[] result = order_by_points([1, -11, -32, 43, 54, -98, 2, -3]);\n    int[] expected = [-3, -32, -98, -11, 1, 2, 43, 54];\n    test:assertEquals(result, expected, msg = \"Negative numbers test failed\");\n}\n\n@test:Config { }\nfunction testOrderByPointsSequential() {\n    int[] result = order_by_points([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n    int[] expected = [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9];\n    test:assertEquals(result, expected, msg = \"Sequential numbers test failed\");\n}\n\n@test:Config { }\nfunction testOrderByPointsMixed() {\n    int[] result = order_by_points([0, 6, 6, -76, -21, 23, 4]);\n    int[] expected = [-76, -21, 0, 4, 23, 6, 6];\n    test:assertEquals(result, expected, msg = \"Mixed numbers test failed\");\n}"
  },
  {
    "id": "request-142",
    "prompt": "Write a function that takes an array of numbers as input and returns the number of elements in the array that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n\nFor example:\nspecialFilter([15, -73, 14, -15]) should return 1\nspecialFilter([33, -2, -3, 45, 21, 109]) should return 2\n\nfunction specialFilter(int[] nums) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSpecialFilter1() {\n    int result = specialFilter([5, -2, 1, -5]);\n    test:assertEquals(result, 0, msg = \"Failed for [5, -2, 1, -5]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter2() {\n    int result = specialFilter([15, -73, 14, -15]);\n    test:assertEquals(result, 1, msg = \"Failed for [15, -73, 14, -15]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter3() {\n    int result = specialFilter([33, -2, -3, 45, 21, 109]);\n    test:assertEquals(result, 2, msg = \"Failed for [33, -2, -3, 45, 21, 109]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter4() {\n    int result = specialFilter([43, -12, 93, 125, 121, 109]);\n    test:assertEquals(result, 4, msg = \"Failed for [43, -12, 93, 125, 121, 109]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter5() {\n    int result = specialFilter([71, -2, -33, 75, 21, 19]);\n    test:assertEquals(result, 3, msg = \"Failed for [71, -2, -33, 75, 21, 19]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter6() {\n    int result = specialFilter([1]);\n    test:assertEquals(result, 0, msg = \"Failed for [1]\");\n}\n\n@test:Config { }\nfunction testSpecialFilter7() {\n    int result = specialFilter([]);\n    test:assertEquals(result, 0, msg = \"Failed for empty array\");\n}"
  },
  {
    "id": "request-143",
    "prompt": "You are given a positive integer n. You have to create an integer array a of length n.\nFor each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\nReturn the number of triples (a[i], a[j], a[k]) of a where i < j < k, \nand a[i] + a[j] + a[k] is a multiple of 3.\n\nExample:\nget_max_triples(5) should return 1\nExplanation: \na = [1, 3, 7, 13, 21]\nThe only valid triple is (1, 7, 13).\n\nfunction get_max_triples(int n) returns int {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGetMaxTriples() {\n    test:assertEquals(get_max_triples(5), 1, msg = \"Test case 1 failed\");\n    test:assertEquals(get_max_triples(6), 4, msg = \"Test case 2 failed\");\n    test:assertEquals(get_max_triples(10), 36, msg = \"Test case 3 failed\");\n    test:assertEquals(get_max_triples(100), 53361, msg = \"Test case 4 failed\");\n}"
  },
  {
    "id": "request-144",
    "prompt": "Write a function that accepts an array of strings, removes all strings with odd lengths, and returns the remaining strings sorted in a specific order. The sorting should be done first by length (ascending), and if two strings have the same length, they should be sorted alphabetically. The function should return an array of strings.\n\nFor example:\n// sorted_list_sum([\"aa\", \"a\", \"aaa\"]) should return [\"aa\"]\n// sorted_list_sum([\"ab\", \"a\", \"aaa\", \"cd\"]) should return [\"ab\", \"cd\"]\n\nfunction sorted_list_sum(lst: string[]): string[] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSortedListSum1() {\n    string[] result = sorted_list_sum([\"aa\", \"a\", \"aaa\"]);\n    string[] expected = [\"aa\"];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum2() {\n    string[] result = sorted_list_sum([\"school\", \"AI\", \"asdf\", \"b\"]);\n    string[] expected = [\"AI\", \"asdf\", \"school\"];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum3() {\n    string[] result = sorted_list_sum([\"d\", \"b\", \"c\", \"a\"]);\n    string[] expected = [];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum4() {\n    string[] result = sorted_list_sum([\"d\", \"dcba\", \"abcd\", \"a\"]);\n    string[] expected = [\"abcd\", \"dcba\"];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum5() {\n    string[] result = sorted_list_sum([\"AI\", \"ai\", \"au\"]);\n    string[] expected = [\"AI\", \"ai\", \"au\"];\n    test:assertEquals(result, expected, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum6() {\n    string[] result = sorted_list_sum([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]);\n    string[] expected = [];\n    test:assertEquals(result, expected, msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testSortedListSum7() {\n    string[] result = sorted_list_sum([\"aaaa\", \"bbbb\", \"dd\", \"cc\"]);\n    string[] expected = [\"cc\", \"dd\", \"aaaa\", \"bbbb\"];\n    test:assertEquals(result, expected, msg = \"Test case 7 failed\");\n}"
  },
  {
    "id": "request-145",
    "prompt": "Write a function that takes three parameters: n, x, and y. The function should return the value of x if n is a prime number, and return the value of y otherwise.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\n```ballerina\nfunction x_or_y(n int, x int, y int) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n```ballerina\nx_or_y(7, 34, 12) // returns 34 (7 is prime)\nx_or_y(15, 8, 5)  // returns 5 (15 is not prime)\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testXOrY1() {\n    test:assertEquals(x_or_y(7, 34, 12), 34);\n}\n\n@test:Config { }\nfunction testXOrY2() {\n    test:assertEquals(x_or_y(15, 8, 5), 5);\n}\n\n@test:Config { }\nfunction testXOrY3() {\n    test:assertEquals(x_or_y(3, 33, 5212), 33);\n}\n\n@test:Config { }\nfunction testXOrY4() {\n    test:assertEquals(x_or_y(1259, 3, 52), 3);\n}\n\n@test:Config { }\nfunction testXOrY5() {\n    test:assertEquals(x_or_y(7919, -1, 12), -1);\n}\n\n@test:Config { }\nfunction testXOrY6() {\n    test:assertEquals(x_or_y(3609, 1245, 583), 583);\n}\n\n@test:Config { }\nfunction testXOrY7() {\n    test:assertEquals(x_or_y(91, 56, 129), 129);\n}\n\n@test:Config { }\nfunction testXOrY8() {\n    test:assertEquals(x_or_y(6, 34, 1234), 1234);\n}\n\n@test:Config { }\nfunction testXOrY9() {\n    test:assertEquals(x_or_y(1, 2, 0), 0);\n}\n\n@test:Config { }\nfunction testXOrY10() {\n    test:assertEquals(x_or_y(2, 2, 0), 2);\n}"
  },
  {
    "id": "request-146",
    "prompt": "Given an array of numbers, return the sum of squares of the numbers in the array that are odd. Ignore numbers that are negative or not integers. If the input array is empty, return 0.\n\n```ballerina\nfunction double_the_difference(lst decimal[]) returns int {\n    // Your implementation here\n}\n```\n\nExamples:\n- double_the_difference([1, 3, 2, 0]) should return 10 (1² + 3² = 1 + 9 = 10)\n- double_the_difference([-1, -2, 0]) should return 0 (no positive odd integers)\n- double_the_difference([9, -2]) should return 81 (9² = 81)\n- double_the_difference([0]) should return 0 (0 is even)",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEmptyArray() {\n    decimal[] lst = [];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 0, msg = \"Empty array should return 0\");\n}\n\n@test:Config { }\nfunction testPositiveNumbers() {\n    decimal[] lst = [5.0, 4.0];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 25, msg = \"Should return 25 for [5.0, 4.0]\");\n}\n\n@test:Config { }\nfunction testDecimalNumbers() {\n    decimal[] lst = [0.1, 0.2, 0.3];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 0, msg = \"Decimal numbers should be ignored\");\n}\n\n@test:Config { }\nfunction testNegativeNumbers() {\n    decimal[] lst = [-10.0, -20.0, -30.0];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 0, msg = \"Negative numbers should be ignored\");\n}\n\n@test:Config { }\nfunction testMixedNegativeAndPositive() {\n    decimal[] lst = [-1.0, -2.0, 8.0];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 0, msg = \"Should ignore negatives and even numbers\");\n}\n\n@test:Config { }\nfunction testMixedWithDecimal() {\n    decimal[] lst = [0.2, 3.0, 5.0];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 34, msg = \"Should return 34 for [0.2, 3.0, 5.0]\");\n}\n\n@test:Config { }\nfunction testMixedPositiveNegative() {\n    decimal[] lst = [-9.0, -7.0, -5.0, -3.0, -1.0, 1.0, 3.0, 5.0, 7.0, 9.0];\n    int result = double_the_difference(lst);\n    test:assertEquals(result, 165, msg = \"Should return 165 for mixed array\");\n}"
  },
  {
    "id": "request-147",
    "prompt": "You need to determine how accurate a person's guesses were for a series of match results. Given two arrays of equal length - one containing actual scores and another containing guesses - return an array showing how far off each guess was from the actual result.\n\nIf the guess is correct, return 0 for that position. If incorrect, return the absolute difference between the guess and the actual score.\n\nWrite a function with this signature:\n```ballerina\nfunction compare(game int[], guess int[]) returns int[]\n```\n\nExamples:\n```ballerina\n// compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]) should return [0, 0, 0, 0, 3, 3]\n// compare([0, 5, 0, 0, 0, 4], [4, 1, 1, 0, 0, -2]) should return [4, 4, 1, 0, 0, 6]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCompareBasic() {\n    int[] result = compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2]);\n    int[] expected = [0, 0, 0, 0, 3, 3];\n    test:assertEquals(result, expected, msg = \"Basic comparison test failed\");\n}\n\n@test:Config { }\nfunction testCompareAllZeros() {\n    int[] result = compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]);\n    int[] expected = [0, 0, 0, 0, 0, 0];\n    test:assertEquals(result, expected, msg = \"All zeros comparison test failed\");\n}\n\n@test:Config { }\nfunction testCompareNegativeGuesses() {\n    int[] result = compare([1, 2, 3], [-1, -2, -3]);\n    int[] expected = [2, 4, 6];\n    test:assertEquals(result, expected, msg = \"Negative guesses comparison test failed\");\n}\n\n@test:Config { }\nfunction testCompareMixed() {\n    int[] result = compare([1, 2, 3, 5], [-1, 2, 3, 4]);\n    int[] expected = [2, 0, 0, 1];\n    test:assertEquals(result, expected, msg = \"Mixed comparison test failed\");\n}"
  },
  {
    "id": "request-148",
    "prompt": "You will be given the name of a class (a string) and an array of extensions. The extensions are to be used to load additional classes to the class. The strength of the extension is calculated as follows: Let CAP be the number of uppercase letters in the extension's name, and let SM be the number of lowercase letters in the extension's name, the strength is given by CAP - SM. You should find the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there are two or more extensions with the same strength, you should choose the one that comes first in the array.\n\nFor example, if you are given \"Slices\" as the class and an array of extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension (its strength is -1).\n\nExample:\n// Strongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n// \"my_class.AA\"\n\nfunction Strongest_Extension(class_name string, extensions string[]) returns string {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStrongestExtension1() {\n    string result = Strongest_Extension(\"Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]);\n    test:assertEquals(result, \"Watashi.eIGHt8OKe\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension2() {\n    string result = Strongest_Extension(\"Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]);\n    test:assertEquals(result, \"Boku123.YEs.WeCaNe\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension3() {\n    string result = Strongest_Extension(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"]);\n    test:assertEquals(result, \"__YESIMHERE.NuLl__\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension4() {\n    string result = Strongest_Extension(\"K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]);\n    test:assertEquals(result, \"K.TAR\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension5() {\n    string result = Strongest_Extension(\"__HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]);\n    test:assertEquals(result, \"__HAHA.123\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension6() {\n    string result = Strongest_Extension(\"YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]);\n    test:assertEquals(result, \"YameRore.okIWILL123\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension7() {\n    string result = Strongest_Extension(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"WoW\"]);\n    test:assertEquals(result, \"finNNalLLly.WoW\", msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension8() {\n    string result = Strongest_Extension(\"_\", [\"Bb\", \"91245\"]);\n    test:assertEquals(result, \"_.Bb\", msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testStrongestExtension9() {\n    string result = Strongest_Extension(\"Sp\", [\"671235\", \"Bb\"]);\n    test:assertEquals(result, \"Sp.671235\", msg = \"Test case 9 failed\");\n}"
  },
  {
    "id": "request-149",
    "prompt": "You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word.\n\n// cycpattern_check(\"abcd\", \"abd\") → false\n// cycpattern_check(\"hello\", \"ell\") → true  \n// cycpattern_check(\"whassup\", \"psus\") → false\n// cycpattern_check(\"abab\", \"baa\") → true\n// cycpattern_check(\"efef\", \"eeff\") → false\n// cycpattern_check(\"himenss\", \"simen\") → true\n\nfunction cycpattern_check(a string, b string) returns boolean {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testCycpatternCheck1() {\n    boolean result = cycpattern_check(\"xyzw\", \"xyw\");\n    test:assertFalse(result, msg = \"Expected false for cycpattern_check(\\\"xyzw\\\", \\\"xyw\\\")\");\n}\n\n@test:Config { }\nfunction testCycpatternCheck2() {\n    boolean result = cycpattern_check(\"yello\", \"ell\");\n    test:assertTrue(result, msg = \"Expected true for cycpattern_check(\\\"yello\\\", \\\"ell\\\")\");\n}\n\n@test:Config { }\nfunction testCycpatternCheck3() {\n    boolean result = cycpattern_check(\"whattup\", \"ptut\");\n    test:assertFalse(result, msg = \"Expected false for cycpattern_check(\\\"whattup\\\", \\\"ptut\\\")\");\n}\n\n@test:Config { }\nfunction testCycpatternCheck4() {\n    boolean result = cycpattern_check(\"efef\", \"fee\");\n    test:assertTrue(result, msg = \"Expected true for cycpattern_check(\\\"efef\\\", \\\"fee\\\")\");\n}\n\n@test:Config { }\nfunction testCycpatternCheck5() {\n    boolean result = cycpattern_check(\"abab\", \"aabb\");\n    test:assertFalse(result, msg = \"Expected false for cycpattern_check(\\\"abab\\\", \\\"aabb\\\")\");\n}\n\n@test:Config { }\nfunction testCycpatternCheck6() {\n    boolean result = cycpattern_check(\"winemtt\", \"tinem\");\n    test:assertTrue(result, msg = \"Expected true for cycpattern_check(\\\"winemtt\\\", \\\"tinem\\\")\");\n}"
  },
  {
    "id": "request-150",
    "prompt": "Given an integer, return an array that has the number of even and odd digits respectively.\n\nExamples:\n// even_odd_count(-12) should return [1, 1] (one even digit: 2, one odd digit: 1)\n// even_odd_count(123) should return [1, 2] (one even digit: 2, two odd digits: 1, 3)\n\nfunction even_odd_count(num int) returns [int, int] {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEvenOddCountSingle() {\n    [int, int] result = even_odd_count(7);\n    test:assertEquals(result, [0, 1], msg = \"Failed for single odd digit\");\n}\n\n@test:Config { }\nfunction testEvenOddCountNegative() {\n    [int, int] result = even_odd_count(-78);\n    test:assertEquals(result, [1, 1], msg = \"Failed for negative number with mixed digits\");\n}\n\n@test:Config { }\nfunction testEvenOddCountBalanced() {\n    [int, int] result = even_odd_count(3452);\n    test:assertEquals(result, [2, 2], msg = \"Failed for balanced even and odd digits\");\n}\n\n@test:Config { }\nfunction testEvenOddCountLargeBalanced() {\n    [int, int] result = even_odd_count(346211);\n    test:assertEquals(result, [3, 3], msg = \"Failed for large number with balanced digits\");\n}\n\n@test:Config { }\nfunction testEvenOddCountLargeNegative() {\n    [int, int] result = even_odd_count(-345821);\n    test:assertEquals(result, [3, 3], msg = \"Failed for large negative number\");\n}\n\n@test:Config { }\nfunction testEvenOddCountNegativeEven() {\n    [int, int] result = even_odd_count(-2);\n    test:assertEquals(result, [1, 0], msg = \"Failed for single negative even digit\");\n}\n\n@test:Config { }\nfunction testEvenOddCountNegativeMixed() {\n    [int, int] result = even_odd_count(-45347);\n    test:assertEquals(result, [2, 3], msg = \"Failed for negative number with more odd digits\");\n}\n\n@test:Config { }\nfunction testEvenOddCountZero() {\n    [int, int] result = even_odd_count(0);\n    test:assertEquals(result, [1, 0], msg = \"Failed for zero\");\n}"
  },
  {
    "id": "request-151",
    "prompt": "Given a positive integer, obtain its roman numeral equivalent as a string, and return it in lowercase.\nRestrictions: 1 <= num <= 1000\n\nExamples:\nint_to_mini_roman(19) // \"xix\"\nint_to_mini_roman(152) // \"clii\" \nint_to_mini_roman(426) // \"cdxxvi\"\n\nfunction int_to_mini_roman(number int) returns string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testIntToMiniRoman() {\n    test:assertEquals(int_to_mini_roman(19), \"xix\", msg = \"Failed for input 19\");\n    test:assertEquals(int_to_mini_roman(152), \"clii\", msg = \"Failed for input 152\");\n    test:assertEquals(int_to_mini_roman(251), \"ccli\", msg = \"Failed for input 251\");\n    test:assertEquals(int_to_mini_roman(426), \"cdxxvi\", msg = \"Failed for input 426\");\n    test:assertEquals(int_to_mini_roman(500), \"d\", msg = \"Failed for input 500\");\n    test:assertEquals(int_to_mini_roman(1), \"i\", msg = \"Failed for input 1\");\n    test:assertEquals(int_to_mini_roman(4), \"iv\", msg = \"Failed for input 4\");\n    test:assertEquals(int_to_mini_roman(43), \"xliii\", msg = \"Failed for input 43\");\n    test:assertEquals(int_to_mini_roman(90), \"xc\", msg = \"Failed for input 90\");\n    test:assertEquals(int_to_mini_roman(94), \"xciv\", msg = \"Failed for input 94\");\n    test:assertEquals(int_to_mini_roman(532), \"dxxxii\", msg = \"Failed for input 532\");\n    test:assertEquals(int_to_mini_roman(900), \"cm\", msg = \"Failed for input 900\");\n    test:assertEquals(int_to_mini_roman(994), \"cmxciv\", msg = \"Failed for input 994\");\n    test:assertEquals(int_to_mini_roman(1000), \"m\", msg = \"Failed for input 1000\");\n}"
  },
  {
    "id": "request-152",
    "prompt": "Given the lengths of the three sides of a triangle, return true if the three sides form a right-angled triangle, false otherwise. A right-angled triangle is a triangle in which one angle is a right angle or 90 degrees.\n\nExample:\n// right_angle_triangle(3, 4, 5) should return true\n// right_angle_triangle(1, 2, 3) should return false\n\nfunction right_angle_triangle(int a, int b, int c) returns boolean {\n\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testRightAngleTriangle1() {\n    boolean result = right_angle_triangle(3, 4, 5);\n    test:assertTrue(result, msg = \"3, 4, 5 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle2() {\n    boolean result = right_angle_triangle(1, 2, 3);\n    test:assertFalse(result, msg = \"1, 2, 3 should not form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle3() {\n    boolean result = right_angle_triangle(10, 6, 8);\n    test:assertTrue(result, msg = \"10, 6, 8 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle4() {\n    boolean result = right_angle_triangle(2, 2, 2);\n    test:assertFalse(result, msg = \"2, 2, 2 should not form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle5() {\n    boolean result = right_angle_triangle(7, 24, 25);\n    test:assertTrue(result, msg = \"7, 24, 25 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle6() {\n    boolean result = right_angle_triangle(10, 5, 7);\n    test:assertFalse(result, msg = \"10, 5, 7 should not form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle7() {\n    boolean result = right_angle_triangle(5, 12, 13);\n    test:assertTrue(result, msg = \"5, 12, 13 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle8() {\n    boolean result = right_angle_triangle(15, 8, 17);\n    test:assertTrue(result, msg = \"15, 8, 17 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle9() {\n    boolean result = right_angle_triangle(48, 55, 73);\n    test:assertTrue(result, msg = \"48, 55, 73 should form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle10() {\n    boolean result = right_angle_triangle(1, 1, 1);\n    test:assertFalse(result, msg = \"1, 1, 1 should not form a right-angled triangle\");\n}\n\n@test:Config { }\nfunction testRightAngleTriangle11() {\n    boolean result = right_angle_triangle(2, 2, 10);\n    test:assertFalse(result, msg = \"2, 2, 10 should not form a right-angled triangle\");\n}"
  },
  {
    "id": "request-153",
    "prompt": "Write a function that accepts an array of strings and returns the word with the maximum number of unique characters. If multiple strings have the same maximum number of unique characters, return the one which comes first in lexicographical order.\n\n```ballerina\nfunction find_max(string[] words) returns string {\n    // Your implementation here\n}\n```\n\nExamples:\n```ballerina\nfind_max([\"name\", \"of\", \"string\"]) // \"string\"\nfind_max([\"name\", \"enam\", \"game\"]) // \"enam\" \nfind_max([\"aaaaaaa\", \"bb\", \"cc\"]) // \"aaaaaaa\"\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testFindMax1() {\n    string result = find_max([\"name\", \"of\", \"string\"]);\n    test:assertEquals(result, \"string\", msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testFindMax2() {\n    string result = find_max([\"name\", \"enam\", \"game\"]);\n    test:assertEquals(result, \"enam\", msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testFindMax3() {\n    string result = find_max([\"aaaaaaa\", \"bb\", \"cc\"]);\n    test:assertEquals(result, \"aaaaaaa\", msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testFindMax4() {\n    string result = find_max([\"abc\", \"cba\"]);\n    test:assertEquals(result, \"abc\", msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testFindMax5() {\n    string result = find_max([\"play\", \"this\", \"game\", \"of\", \"footbott\"]);\n    test:assertEquals(result, \"footbott\", msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testFindMax6() {\n    string result = find_max([\"we\", \"are\", \"gonna\", \"rock\"]);\n    test:assertEquals(result, \"gonna\", msg = \"Test case 6 failed\");\n}\n\n@test:Config { }\nfunction testFindMax7() {\n    string result = find_max([\"we\", \"are\", \"a\", \"mad\", \"nation\"]);\n    test:assertEquals(result, \"nation\", msg = \"Test case 7 failed\");\n}\n\n@test:Config { }\nfunction testFindMax8() {\n    string result = find_max([\"this\", \"is\", \"a\", \"prrk\"]);\n    test:assertEquals(result, \"this\", msg = \"Test case 8 failed\");\n}\n\n@test:Config { }\nfunction testFindMax9() {\n    string result = find_max([\"b\"]);\n    test:assertEquals(result, \"b\", msg = \"Test case 9 failed\");\n}\n\n@test:Config { }\nfunction testFindMax10() {\n    string result = find_max([\"play\", \"play\", \"play\"]);\n    test:assertEquals(result, \"play\", msg = \"Test case 10 failed\");\n}"
  },
  {
    "id": "request-154",
    "prompt": "You're a hungry rabbit, and you already have eaten a certain number of carrots, but now you need to eat more carrots to complete the day's meals. You should return an array of [total number of eaten carrots after your meals, the number of carrots left after your meals]. If there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n\nWrite a function `eat` that takes three parameters:\n- `number`: the number of carrots that you have already eaten\n- `need`: the number of carrots that you need to eat  \n- `remaining`: the number of remaining carrots that exist in stock\n\nThe function should return an array of two integers representing the total carrots eaten and carrots remaining.\n\nFunction signature: `function eat(int number, int need, int remaining) returns int[]`\n\nExamples:\n// eat(5, 6, 10) returns [11, 4]\n// eat(4, 8, 9) returns [12, 1] \n// eat(1, 10, 10) returns [11, 0]\n// eat(2, 11, 5) returns [7, 0]\n\nConstraints:\n- 0 <= number <= 1000\n- 0 <= need <= 1000  \n- 0 <= remaining <= 1000",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testEat1() {\n    int[] result = eat(5, 6, 10);\n    int[] expected = [11, 4];\n    test:assertEquals(result, expected, msg = \"Test case 1 failed\");\n}\n\n@test:Config { }\nfunction testEat2() {\n    int[] result = eat(4, 8, 9);\n    int[] expected = [12, 1];\n    test:assertEquals(result, expected, msg = \"Test case 2 failed\");\n}\n\n@test:Config { }\nfunction testEat3() {\n    int[] result = eat(1, 10, 10);\n    int[] expected = [11, 0];\n    test:assertEquals(result, expected, msg = \"Test case 3 failed\");\n}\n\n@test:Config { }\nfunction testEat4() {\n    int[] result = eat(2, 11, 5);\n    int[] expected = [7, 0];\n    test:assertEquals(result, expected, msg = \"Test case 4 failed\");\n}\n\n@test:Config { }\nfunction testEat5() {\n    int[] result = eat(4, 5, 7);\n    int[] expected = [9, 2];\n    test:assertEquals(result, expected, msg = \"Test case 5 failed\");\n}\n\n@test:Config { }\nfunction testEat6() {\n    int[] result = eat(4, 5, 1);\n    int[] expected = [5, 0];\n    test:assertEquals(result, expected, msg = \"Test case 6 failed\");\n}"
  },
  {
    "id": "request-155",
    "prompt": "Given two arrays operator and operand, where the first array contains basic algebra operations and the second array contains integers, build an algebraic expression and return its evaluation.\n\nThe basic algebra operations are:\n- Addition ( + ) \n- Subtraction ( - ) \n- Multiplication ( * ) \n- Floor division ( // ) \n- Exponentiation ( ** ) \n\nFor example:\n- operator = ['+', '*', '-']\n- operand = [2, 3, 4, 5]\n- result = 2 + 3 * 4 - 5 = 9\n\nNote: The length of operator array equals the length of operand array minus one. The operand array contains non-negative integers. The operator array has at least one operator, and operand array has at least two operands.\n\nWrite a function with signature:\n```ballerina\nfunction do_algebra(operator string[], operand int[]) returns int\n```\n\nExpected function calls:\n```ballerina\ndo_algebra([\"**\", \"*\", \"+\"], [2, 3, 4, 5]) // returns 37\ndo_algebra([\"+\", \"*\", \"-\"], [2, 3, 4, 5]) // returns 9\ndo_algebra([\"//\", \"*\"], [7, 3, 4]) // returns 8\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testExponentiationMultiplicationAddition() {\n    int result = do_algebra([\"**\", \"*\", \"+\"], [2, 3, 4, 5]);\n    test:assertEquals(result, 37, msg = \"Expected 37 for [\\\"**\\\", \\\"*\\\", \\\"+\\\"] with [2, 3, 4, 5]\");\n}\n\n@test:Config { }\nfunction testAdditionMultiplicationSubtraction() {\n    int result = do_algebra([\"+\", \"*\", \"-\"], [2, 3, 4, 5]);\n    test:assertEquals(result, 9, msg = \"Expected 9 for [\\\"+\\\", \\\"*\\\", \\\"-\\\"] with [2, 3, 4, 5]\");\n}\n\n@test:Config { }\nfunction testFloorDivisionMultiplication() {\n    int result = do_algebra([\"//\", \"*\"], [7, 3, 4]);\n    test:assertEquals(result, 8, msg = \"Expected 8 for [\\\"//\\\", \\\"*\\\"] with [7, 3, 4]\");\n}"
  },
  {
    "id": "request-156",
    "prompt": "You are given a string s. For each character in the string:\n- If the character is a letter, reverse its case (lowercase to uppercase or vice versa)\n- If the character is not a letter, keep it as it is\n- If the string contains no letters at all, reverse the entire string\n\nReturn the resulting string.\n\nExamples:\n// solve(\"1234\") returns \"4321\" (no letters, so reverse the string)\n// solve(\"ab\") returns \"AB\" (reverse case of letters)\n// solve(\"#a@C\") returns \"#A@c\" (reverse case of letters, keep symbols)\n\nfunction solve(s: string) returns string {\n    // Your implementation here\n}",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testSolve() {\n    test:assertEquals(solve(\"AsDf\"), \"aSdF\", msg = \"Failed for mixed case letters\");\n}\n\n@test:Config { }\nfunction testSolveDigitsOnly() {\n    test:assertEquals(solve(\"1234\"), \"4321\", msg = \"Failed for digits only\");\n}\n\n@test:Config { }\nfunction testSolveLowercaseLetters() {\n    test:assertEquals(solve(\"ab\"), \"AB\", msg = \"Failed for lowercase letters\");\n}\n\n@test:Config { }\nfunction testSolveMixedWithSymbols() {\n    test:assertEquals(solve(\"#a@C\"), \"#A@c\", msg = \"Failed for mixed case with symbols\");\n}\n\n@test:Config { }\nfunction testSolveLongMixed() {\n    test:assertEquals(solve(\"#AsdfW^45\"), \"#aSDFw^45\", msg = \"Failed for long mixed string\");\n}\n\n@test:Config { }\nfunction testSolveSymbolsAndDigits() {\n    test:assertEquals(solve(\"#6@2\"), \"2@6#\", msg = \"Failed for symbols and digits only\");\n}\n\n@test:Config { }\nfunction testSolveSymbolsWithLetters() {\n    test:assertEquals(solve(\"#$a^D\"), \"#$A^d\", msg = \"Failed for symbols with letters\");\n}\n\n@test:Config { }\nfunction testSolveRepeatedLetters() {\n    test:assertEquals(solve(\"#ccc\"), \"#CCC\", msg = \"Failed for repeated lowercase letters\");\n}"
  },
  {
    "id": "request-157",
    "prompt": "Given a string 'text', return its MD5 hash equivalent string. If 'text' is an empty string, return null.\n\n```ballerina\nfunction string_to_md5(text string) returns string? {\n    // Your implementation here\n}\n```\n\nExpected behavior:\n- string_to_md5(\"Hello world\") should return \"3e25960a79dbc69b674cd4ec67a72c62\"\n- string_to_md5(\"\") should return null\n- string_to_md5(\"A B C\") should return \"0ef78513b0cb8cef12743f5aeb35f888\"\n- string_to_md5(\"password\") should return \"5f4dcc3b5aa765d61d8327deb882cf99\"",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testStringToMd5HelloWorld() {\n    string? result = string_to_md5(\"Hello world\");\n    test:assertEquals(result, \"3e25960a79dbc69b674cd4ec67a72c62\", msg = \"MD5 hash for 'Hello world' is incorrect\");\n}\n\n@test:Config { }\nfunction testStringToMd5EmptyString() {\n    string? result = string_to_md5(\"\");\n    test:assertEquals(result, (), msg = \"Empty string should return null\");\n}\n\n@test:Config { }\nfunction testStringToMd5ABC() {\n    string? result = string_to_md5(\"A B C\");\n    test:assertEquals(result, \"0ef78513b0cb8cef12743f5aeb35f888\", msg = \"MD5 hash for 'A B C' is incorrect\");\n}\n\n@test:Config { }\nfunction testStringToMd5Password() {\n    string? result = string_to_md5(\"password\");\n    test:assertEquals(result, \"5f4dcc3b5aa765d61d8327deb882cf99\", msg = \"MD5 hash for 'password' is incorrect\");\n}"
  },
  {
    "id": "request-158",
    "prompt": "Given two positive integers a and b, return the even digits between a and b, in ascending order.\n\nFor example:\n- generate_integers(2, 8) should return [2, 4, 6, 8]\n- generate_integers(8, 2) should return [2, 4, 6, 8]  \n- generate_integers(10, 14) should return []\n\nWrite a function with the following signature:\n```ballerina\nfunction generate_integers(int a, int b) returns int[]\n```",
    "test": "import ballerina/test;\n\n@test:Config { }\nfunction testGenerateIntegers1() {\n    int[] result = generate_integers(2, 10);\n    int[] expected = [2, 4, 6, 8];\n    test:assertEquals(result, expected, msg = \"Failed for generate_integers(2, 10)\");\n}\n\n@test:Config { }\nfunction testGenerateIntegers2() {\n    int[] result = generate_integers(10, 2);\n    int[] expected = [2, 4, 6, 8];\n    test:assertEquals(result, expected, msg = \"Failed for generate_integers(10, 2)\");\n}\n\n@test:Config { }\nfunction testGenerateIntegers3() {\n    int[] result = generate_integers(132, 2);\n    int[] expected = [2, 4, 6, 8];\n    test:assertEquals(result, expected, msg = \"Failed for generate_integers(132, 2)\");\n}\n\n@test:Config { }\nfunction testGenerateIntegers4() {\n    int[] result = generate_integers(17, 89);\n    int[] expected = [];\n    test:assertEquals(result, expected, msg = \"Failed for generate_integers(17, 89)\");\n}"
  }
]